# 子代理输出缓冲问题补充说明（2025-10-14）

## 问题现象

在第三次改进后（添加 `--verbose` 标志到子代理命令），用户反馈执行时仍然"卡住"：

```
conversation tokens: 140994 -> 86974 (conversation round: 231)
我将为您创建一个功能丰富的命令行计算工具。让我直接在项目的工具目录中创建这个工具。
```

之后没有任何输出，看起来进程卡住了。

## 根本原因分析

通过 `ps aux` 检查发现子进程确实在运行（PID 658635），这说明不是真的卡住，而是**输出被缓冲了**。

### 缓冲机制

1. **子代理命令层面**：
   - 命令中已添加 `--verbose` 标志 ✓
   - 子进程会产生控制台输出 ✓

2. **CommandExecutor 层面**（问题所在）：
   - `execute_commands()` 函数在 `run_named_subagents_tool_resolver.py:127` 被调用
   - **没有传递 `verbose=True` 参数** ✗
   - 导致 `CommandExecutor` 的 `verbose` 属性为 `False`

3. **输出处理逻辑**（command_executor.py:236-237）：
   ```python
   # Handle verbose output
   if self.verbose and output_str:
       print(output_str, end="", flush=True)
   ```
   - 只有当 `self.verbose=True` 时才打印输出
   - 否则输出被完全缓冲，直到命令执行完成

### 执行流程

```
RunNamedSubagentsTool.resolve()
  ↓
execute_commands(commands, verbose=False)  ← 缺少 verbose=True
  ↓
CommandExecutor.execute_batch()
  ↓
CommandExecutor._execute_batch_serial() or _execute_batch_parallel()
  ↓
CommandExecutor.execute()
  ↓
CommandExecutor._execute_with_subprocess()
  ↓
process.communicate()  ← 等待进程完成，缓冲所有输出
  ↓
if self.verbose:  ← False，不打印
    print(output_str)
```

## 解决方案

在 `run_named_subagents_tool_resolver.py` 调用 `execute_commands()` 时添加 `verbose=True` 参数：

```python
# 启用 verbose 以实时打印子进程输出，避免输出缓冲导致的"卡住"问题
results = execute_commands(
    commands=commands,
    parallel=parallel,
    timeout=timeout_seconds + 60,
    per_command_timeout=timeout_seconds,
    verbose=True  # ← 新增
)
```

## 完整修复链路

修复需要两个层面的配置：

1. **子代理命令层面**（第三次改进）：
   ```bash
   echo 'task' | auto-coder.run --model DSV3 --is-sub-agent --verbose
   ```
   - 确保子进程产生控制台输出

2. **CommandExecutor 层面**（本次补充）：
   ```python
   execute_commands(commands, verbose=True)
   ```
   - 确保 CommandExecutor 实时打印子进程输出

### 修改文件

- `autocoder/common/v2/agent/agentic_edit_tools/run_named_subagents_tool_resolver.py`
  - `resolve()` 方法第127-133行：添加 `verbose=True` 参数

## 技术要点

1. **进程输出流**：
   - 子进程的 stdout/stderr 被父进程的 `subprocess.Popen` 捕获
   - `process.communicate()` 方法会等待进程完成并返回所有输出
   - 这是**阻塞操作**，在此期间不会有任何输出

2. **CommandExecutor 的 verbose 模式**：
   - 当 `verbose=True` 时，`execute()` 方法在命令完成后立即打印输出
   - 当 `verbose=False` 时，输出被完全忽略（返回给调用者但不打印）

3. **为什么看起来"卡住"**：
   - 用户看到了初始的 conversation token 信息
   - 之后子进程在执行，但输出被缓冲
   - 用户没有任何视觉反馈，以为程序卡住了
   - 实际上进程在正常执行，只是输出没有实时显示

## 预期效果

修复后，用户将看到实时输出：

```
conversation tokens: 140994 -> 86974 (conversation round: 231)
我将为您创建一个功能丰富的命令行计算工具。

══════════════════════════════════════════════════════════
📋 SUBAGENT COMMANDS OVERVIEW
══════════════════════════════════════════════════════════
🤖 Subagent #1: go_developer
📝 Task: 创建一个功能丰富的命令行计算工具...
💻 Command: echo '...' | auto-coder.run --model DSV3 ...
══════════════════════════════════════════════════════════

[子进程实时输出]
Reading file: main.go
Writing to file: calculator.go
...

✅ Task completed successfully
```

## 经验总结

1. **多层缓冲问题**：
   - 日志系统的缓冲（Loguru）
   - 子进程的输出缓冲（subprocess）
   - 父进程的处理逻辑（CommandExecutor）
   - 每一层都可能阻止输出实时显示

2. **调试方法**：
   - 使用 `ps aux` 检查进程是否真的在运行
   - 检查 `.auto-coder/logs/auto-coder.log` 是否有日志写入
   - 跟踪整个调用链路，找出哪一层阻止了输出

3. **配置传递的重要性**：
   - `--verbose` 标志需要正确传递到每一层
   - 子命令的 verbose 和父进程的 verbose 是两个独立的配置
   - 两者都需要配置才能实现端到端的实时输出
