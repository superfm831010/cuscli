# ä»£ç æ£€æŸ¥åŠŸèƒ½äºŒæ¬¡å¼€å‘æŒ‡å—

> é¢å‘å¼€å‘è€…çš„ä»£ç æ£€æŸ¥ç³»ç»Ÿæ¶æ„ã€æ‰©å±•å’Œå®šåˆ¶æŒ‡å—

## ğŸ“‹ ç›®å½•

- [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
- [æ ¸å¿ƒæ¨¡å—è¯¦è§£](#æ ¸å¿ƒæ¨¡å—è¯¦è§£)
- [æ’ä»¶ç³»ç»Ÿ](#æ’ä»¶ç³»ç»Ÿ)
- [æ·»åŠ æ–°è§„åˆ™](#æ·»åŠ æ–°è§„åˆ™)
- [æ‰©å±•æ–°åŠŸèƒ½](#æ‰©å±•æ–°åŠŸèƒ½)
- [API å‚è€ƒ](#api-å‚è€ƒ)
- [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)

---

## æ¶æ„æ¦‚è§ˆ

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Chat Auto Coder                      â”‚
â”‚                     (ä¸»åº”ç”¨)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â”‚ åŠ è½½æ’ä»¶
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CodeCheckerPlugin                          â”‚
â”‚            (å‘½ä»¤æ³¨å†Œå’Œè°ƒåº¦)                              â”‚
â”‚  - æ³¨å†Œ /check å‘½ä»¤                                      â”‚
â”‚  - è§£æå‚æ•°                                              â”‚
â”‚  - è°ƒç”¨æ£€æŸ¥å™¨                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼            â–¼            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  /check  â”‚  â”‚  /check  â”‚  â”‚  /check  â”‚
â”‚  /file   â”‚  â”‚ /folder  â”‚  â”‚ /resume  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚             â”‚              â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    CodeChecker        â”‚
        â”‚   (æ ¸å¿ƒæ£€æŸ¥é€»è¾‘)       â”‚
        â”‚  - åè°ƒå„æ¨¡å—          â”‚
        â”‚  - è°ƒç”¨ LLM           â”‚
        â”‚  - ç»“æœå¤„ç†            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼           â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Rules   â”‚ â”‚  File    â”‚ â”‚Progress  â”‚
â”‚  Loader  â”‚ â”‚Processor â”‚ â”‚ Tracker  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Report Generator    â”‚
        â”‚   (ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š)       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—å…³ç³»

| æ¨¡å— | æ–‡ä»¶ | èŒè´£ | ä¾èµ– |
|------|------|------|------|
| **æ’ä»¶** | `code_checker_plugin.py` | å‘½ä»¤æ³¨å†Œã€å‚æ•°è§£æ | CodeChecker |
| **æ ¸å¿ƒæ£€æŸ¥å™¨** | `core.py` | æ£€æŸ¥é€»è¾‘ã€LLM è°ƒç”¨ | æ‰€æœ‰æ¨¡å— |
| **è§„åˆ™åŠ è½½å™¨** | `rules_loader.py` | è§„åˆ™æ–‡ä»¶è§£æ | types.py |
| **æ–‡ä»¶å¤„ç†å™¨** | `file_processor.py` | æ–‡ä»¶æ‰«æã€åˆ†å— | types.py |
| **è¿›åº¦è·Ÿè¸ªå™¨** | `progress_tracker.py` | è¿›åº¦æŒä¹…åŒ– | types.py |
| **æŠ¥å‘Šç”Ÿæˆå™¨** | `report_generator.py` | æŠ¥å‘Šç”Ÿæˆ | types.py |
| **ç±»å‹å®šä¹‰** | `types.py` | æ•°æ®æ¨¡å‹ | pydantic |

### æ•°æ®æµ

```
1. ç”¨æˆ·è¾“å…¥å‘½ä»¤
   â†“
2. Plugin è§£æå‚æ•°
   â†“
3. CodeChecker.check_file() æˆ– check_files()
   â†“
4. RulesLoader åŠ è½½è§„åˆ™
   â†“
5. FileProcessor æ‰«æ/åˆ†å—æ–‡ä»¶
   â†“
6. CodeChecker è°ƒç”¨ LLM æ£€æŸ¥
   â†“
7. è§£æ LLM è¿”å›çš„ JSON
   â†“
8. ReportGenerator ç”ŸæˆæŠ¥å‘Š
   â†“
9. ProgressTracker ä¿å­˜è¿›åº¦
   â†“
10. è¿”å›ç»“æœç»™ç”¨æˆ·
```

---

## æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 1. types.py - ç±»å‹å®šä¹‰

**ä½ç½®**ï¼š`autocoder/checker/types.py`

**æ ¸å¿ƒç±»å‹**ï¼š

#### Severity - ä¸¥é‡ç¨‹åº¦æšä¸¾

```python
class Severity(str, Enum):
    ERROR = "error"      # é”™è¯¯ï¼šå¿…é¡»ä¿®å¤
    WARNING = "warning"  # è­¦å‘Šï¼šå»ºè®®ä¿®å¤
    INFO = "info"        # æç¤ºï¼šå¯é€‰ä¿®å¤
```

#### Rule - è§„åˆ™å®šä¹‰

```python
class Rule(BaseModel):
    id: str                    # è§„åˆ™IDï¼Œå¦‚ "backend_001"
    category: str              # è§„åˆ™ç±»åˆ«ï¼Œå¦‚ "ä»£ç ç»“æ„"
    title: str                 # è§„åˆ™æ ‡é¢˜
    description: str           # è§„åˆ™æè¿°
    severity: Severity         # ä¸¥é‡ç¨‹åº¦
    enabled: bool = True       # æ˜¯å¦å¯ç”¨
    examples: Optional[str]    # ç¤ºä¾‹ä»£ç 
```

#### Issue - æ£€æŸ¥é—®é¢˜

```python
class Issue(BaseModel):
    rule_id: str              # è¿åçš„è§„åˆ™ID
    severity: Severity        # ä¸¥é‡ç¨‹åº¦
    line_start: int           # é—®é¢˜èµ·å§‹è¡Œå·
    line_end: int             # é—®é¢˜ç»“æŸè¡Œå·
    description: str          # é—®é¢˜æè¿°
    suggestion: str           # ä¿®å¤å»ºè®®
    code_snippet: str         # é—®é¢˜ä»£ç ç‰‡æ®µ
```

#### FileCheckResult - æ–‡ä»¶æ£€æŸ¥ç»“æœ

```python
class FileCheckResult(BaseModel):
    file_path: str                # æ–‡ä»¶è·¯å¾„
    check_time: str              # æ£€æŸ¥æ—¶é—´
    issues: List[Issue]          # é—®é¢˜åˆ—è¡¨
    error_count: int             # é”™è¯¯æ•°é‡
    warning_count: int           # è­¦å‘Šæ•°é‡
    info_count: int              # æç¤ºæ•°é‡
    status: str                  # "success" | "failed" | "skipped"
    error_message: Optional[str] # é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
```

#### CheckState - æ£€æŸ¥çŠ¶æ€ï¼ˆç”¨äºæŒä¹…åŒ–ï¼‰

```python
class CheckState(BaseModel):
    check_id: str                  # æ£€æŸ¥ID
    start_time: str               # å¼€å§‹æ—¶é—´
    config: Dict[str, Any]        # é…ç½®å‚æ•°
    total_files: List[str]        # æ€»æ–‡ä»¶åˆ—è¡¨
    completed_files: List[str]    # å·²å®Œæˆæ–‡ä»¶
    remaining_files: List[str]    # å‰©ä½™æ–‡ä»¶
```

**æ‰©å±•å»ºè®®**ï¼š
- æ·»åŠ æ–°çš„ä¸¥é‡ç¨‹åº¦çº§åˆ«ï¼ˆå¦‚ CRITICALï¼‰
- æ·»åŠ è§„åˆ™åˆ†ç»„ï¼ˆRuleGroupï¼‰
- æ·»åŠ æ£€æŸ¥ç»Ÿè®¡ä¿¡æ¯ï¼ˆCheckStatisticsï¼‰

---

### 2. rules_loader.py - è§„åˆ™åŠ è½½å™¨

**ä½ç½®**ï¼š`autocoder/checker/rules_loader.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- åŠ è½½ Markdown æ ¼å¼çš„è§„åˆ™æ–‡ä»¶
- è§£æè§„åˆ™é…ç½®
- æ ¹æ®æ–‡ä»¶ç±»å‹é€‰æ‹©é€‚ç”¨è§„åˆ™
- è§„åˆ™ç¼“å­˜ä¼˜åŒ–

**å…³é”®æ–¹æ³•**ï¼š

#### load_rules() - åŠ è½½è§„åˆ™

```python
def load_rules(self, rule_type: str) -> List[Rule]:
    """
    åŠ è½½æŒ‡å®šç±»å‹çš„è§„åˆ™

    Args:
        rule_type: è§„åˆ™ç±»å‹ï¼ˆbackend/frontendï¼‰

    Returns:
        è§„åˆ™åˆ—è¡¨
    """
    # 1. æ£€æŸ¥ç¼“å­˜
    if rule_type in self._rule_cache:
        return self._rule_cache[rule_type]

    # 2. åŠ è½½è§„åˆ™æ–‡ä»¶
    rule_file = os.path.join(self.rules_dir, f"{rule_type}_rules.md")
    rules = self._parse_markdown_rules(rule_file)

    # 3. åº”ç”¨é…ç½®
    rules = self._apply_config(rules, rule_type)

    # 4. ç¼“å­˜ç»“æœ
    self._rule_cache[rule_type] = rules

    return rules
```

#### _parse_markdown_rules() - è§£æ Markdown è§„åˆ™

```python
def _parse_markdown_rules(self, file_path: str) -> List[Rule]:
    """
    è§£æ Markdown æ ¼å¼çš„è§„åˆ™æ–‡ä»¶

    è§„åˆ™æ ¼å¼ï¼š
    ### è§„åˆ™ID: backend_001
    **æ ‡é¢˜**: è§„åˆ™æ ‡é¢˜
    **ä¸¥é‡ç¨‹åº¦**: warning
    **æè¿°**: è§„åˆ™æè¿°
    """
    rules = []

    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # æŒ‰ "### è§„åˆ™ID:" åˆ†å‰²
    sections = re.split(r'### è§„åˆ™ID:\s*(\w+)', content)

    current_category = ""

    for i in range(1, len(sections), 2):
        rule_id = sections[i].strip()
        rule_content = sections[i+1]

        # æå–å­—æ®µ
        title = self._extract_field(rule_content, "æ ‡é¢˜")
        severity = self._extract_field(rule_content, "ä¸¥é‡ç¨‹åº¦")
        description = self._extract_field(rule_content, "æè¿°")

        # æå–ç¤ºä¾‹
        examples = self._extract_examples(rule_content)

        rules.append(Rule(
            id=rule_id,
            category=current_category,
            title=title,
            description=description,
            severity=Severity(severity),
            examples=examples
        ))

    return rules
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒ YAML/JSON æ ¼å¼çš„è§„åˆ™æ–‡ä»¶
- æ”¯æŒè§„åˆ™ç»§æ‰¿å’Œè¦†ç›–
- æ”¯æŒè§„åˆ™ä¼˜å…ˆçº§
- æ”¯æŒåŠ¨æ€è§„åˆ™ï¼ˆä»æ•°æ®åº“åŠ è½½ï¼‰

---

### 3. file_processor.py - æ–‡ä»¶å¤„ç†å™¨

**ä½ç½®**ï¼š`autocoder/checker/file_processor.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- æ–‡ä»¶æ‰«æå’Œè¿‡æ»¤
- å¤§æ–‡ä»¶åˆ†å—
- æ–‡ä»¶ç±»å‹æ£€æµ‹

**å…³é”®æ–¹æ³•**ï¼š

#### scan_files() - æ‰«ææ–‡ä»¶

```python
def scan_files(self, path: str, filters: FileFilters) -> List[str]:
    """
    æ‰«æç›®å½•ï¼Œè¿”å›ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶åˆ—è¡¨

    Args:
        path: æ‰«æè·¯å¾„
        filters: æ–‡ä»¶è¿‡æ»¤å™¨ï¼ˆæ‰©å±•åã€å¿½ç•¥æ¨¡å¼ï¼‰

    Returns:
        æ–‡ä»¶è·¯å¾„åˆ—è¡¨
    """
    files = []

    for root, dirs, filenames in os.walk(path):
        # è¿‡æ»¤å¿½ç•¥çš„ç›®å½•
        dirs[:] = [d for d in dirs if not self._should_ignore(d, filters.ignored)]

        for filename in filenames:
            file_path = os.path.join(root, filename)

            # æ£€æŸ¥æ‰©å±•å
            if filters.extensions:
                if not any(file_path.endswith(ext) for ext in filters.extensions):
                    continue

            # æ£€æŸ¥å¿½ç•¥æ¨¡å¼
            if self._should_ignore(file_path, filters.ignored):
                continue

            # æ£€æŸ¥æ˜¯å¦å¯æ£€æŸ¥
            if self.is_checkable(file_path):
                files.append(file_path)

    return files
```

#### chunk_file() - æ–‡ä»¶åˆ†å—

```python
def chunk_file(self, file_path: str) -> List[CodeChunk]:
    """
    å°†å¤§æ–‡ä»¶åˆ†å—ï¼Œç¡®ä¿æ¯å—ä¸è¶…è¿‡ token é™åˆ¶

    ç­–ç•¥ï¼š
    1. ä¸ºæ¯è¡Œæ·»åŠ è¡Œå·
    2. è®¡ç®—æ€» token æ•°
    3. å¦‚æœè¶…è¿‡é™åˆ¶ï¼ŒæŒ‰ token åˆ†å—
    4. å—ä¹‹é—´æœ‰é‡å ï¼Œé¿å…è¾¹ç•Œé—®é¢˜
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # æ·»åŠ è¡Œå·
    numbered_lines = [f"{i+1} {line}" for i, line in enumerate(lines)]

    # è®¡ç®— tokens
    total_tokens = count_tokens('\n'.join(numbered_lines))

    # ä¸éœ€è¦åˆ†å—
    if total_tokens <= self.chunk_size:
        return [CodeChunk(
            content='\n'.join(numbered_lines),
            start_line=1,
            end_line=len(lines),
            chunk_index=0,
            total_chunks=1
        )]

    # éœ€è¦åˆ†å—
    chunks = []
    current_line = 0
    chunk_index = 0

    while current_line < len(numbered_lines):
        # è®¡ç®—å½“å‰ chunk çš„ç»“æŸè¡Œ
        end_line = self._calculate_chunk_end(
            numbered_lines,
            current_line,
            self.chunk_size
        )

        # åˆ›å»º chunk
        chunk_content = '\n'.join(numbered_lines[current_line:end_line])
        chunks.append(CodeChunk(
            content=chunk_content,
            start_line=current_line + 1,
            end_line=end_line,
            chunk_index=chunk_index,
            total_chunks=0  # ç¨åæ›´æ–°
        ))

        # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª chunkï¼ˆè€ƒè™‘é‡å ï¼‰
        current_line = end_line - self.overlap
        chunk_index += 1

    # æ›´æ–°æ€» chunk æ•°
    for chunk in chunks:
        chunk.total_chunks = len(chunks)

    return chunks
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒæ™ºèƒ½åˆ†å—ï¼ˆæŒ‰å‡½æ•°/ç±»è¾¹ç•Œï¼‰
- æ”¯æŒå¢é‡æ£€æŸ¥ï¼ˆåªæ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶ï¼‰
- æ”¯æŒ Git diff é›†æˆ
- æ”¯æŒæ–‡ä»¶å†…å®¹ç¼“å­˜

---

### 4. core.py - æ ¸å¿ƒæ£€æŸ¥å™¨

**ä½ç½®**ï¼š`autocoder/checker/core.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- åè°ƒå„æ¨¡å—å®Œæˆæ£€æŸ¥
- è°ƒç”¨ LLM è¿›è¡Œä»£ç æ£€æŸ¥
- å¤„ç†æ£€æŸ¥ç»“æœ
- ç®¡ç†å¹¶å‘æ‰§è¡Œ

**å…³é”®æ–¹æ³•**ï¼š

#### check_file() - å•æ–‡ä»¶æ£€æŸ¥

```python
def check_file(self, file_path: str) -> FileCheckResult:
    """
    æ£€æŸ¥å•ä¸ªæ–‡ä»¶

    æµç¨‹ï¼š
    1. åŠ è½½é€‚ç”¨è§„åˆ™
    2. è¯»å–æ–‡ä»¶å¹¶åˆ†å—
    3. æ£€æŸ¥æ¯ä¸ª chunk
    4. åˆå¹¶ç»“æœ
    5. è¿”å›æ£€æŸ¥ç»“æœ
    """
    try:
        start_time = datetime.now()

        # 1. è·å–é€‚ç”¨è§„åˆ™
        rules = self.rules_loader.get_applicable_rules(file_path)
        if not rules:
            return FileCheckResult(
                file_path=file_path,
                check_time=start_time.isoformat(),
                issues=[],
                status="skipped"
            )

        # 2. åˆ†å—å¤„ç†
        chunks = self.file_processor.chunk_file(file_path)
        logger.info(f"æ–‡ä»¶ {file_path} è¢«åˆ†ä¸º {len(chunks)} ä¸ª chunks")

        # 3. æ£€æŸ¥æ¯ä¸ª chunk
        all_issues = []
        for chunk in chunks:
            issues = self.check_code_chunk(chunk.content, rules)
            all_issues.extend(issues)

        # 4. åˆå¹¶é‡å¤é—®é¢˜
        merged_issues = self._merge_duplicate_issues(all_issues)

        # 5. ç»Ÿè®¡
        error_count = sum(1 for i in merged_issues if i.severity == Severity.ERROR)
        warning_count = sum(1 for i in merged_issues if i.severity == Severity.WARNING)
        info_count = sum(1 for i in merged_issues if i.severity == Severity.INFO)

        return FileCheckResult(
            file_path=file_path,
            check_time=datetime.now().isoformat(),
            issues=merged_issues,
            error_count=error_count,
            warning_count=warning_count,
            info_count=info_count,
            status="success"
        )

    except Exception as e:
        logger.error(f"æ£€æŸ¥æ–‡ä»¶ {file_path} å¤±è´¥: {e}")
        return FileCheckResult(
            file_path=file_path,
            check_time=datetime.now().isoformat(),
            issues=[],
            error_count=0,
            warning_count=0,
            info_count=0,
            status="failed",
            error_message=str(e)
        )
```

#### check_code_chunk() - æ£€æŸ¥ä»£ç å—

```python
@byzerllm.prompt()
def check_code_prompt(self, code_with_lines: str, rules: str) -> str:
    """
    ä½ æ˜¯ä¸€ä¸ªä»£ç å®¡æŸ¥ä¸“å®¶ã€‚è¯·æ ¹æ®æä¾›çš„è§„åˆ™æ£€æŸ¥ä»£ç ï¼Œæ‰¾å‡ºä¸ç¬¦åˆè§„èŒƒçš„åœ°æ–¹ã€‚

    ## æ£€æŸ¥è§„åˆ™

    {{ rules }}

    ## å¾…æ£€æŸ¥ä»£ç ï¼ˆå¸¦è¡Œå·ï¼‰

    ```
    {{ code_with_lines }}
    ```

    ## è¾“å‡ºè¦æ±‚

    è¯·ä»”ç»†æ£€æŸ¥ä»£ç ï¼Œå¯¹äºæ¯ä¸ªå‘ç°çš„é—®é¢˜ï¼š
    1. å‡†ç¡®å®šä½é—®é¢˜çš„èµ·å§‹å’Œç»“æŸè¡Œå·
    2. å¼•ç”¨è¿åçš„è§„åˆ™ID
    3. æè¿°é—®é¢˜
    4. æä¾›ä¿®å¤å»ºè®®

    ä»¥ JSON æ•°ç»„æ ¼å¼è¾“å‡ºï¼Œæ¯ä¸ªé—®é¢˜åŒ…å«ï¼š
    - rule_id: è¿åçš„è§„åˆ™ID
    - severity: ä¸¥é‡ç¨‹åº¦ (error/warning/info)
    - line_start: é—®é¢˜èµ·å§‹è¡Œå·ï¼ˆæ•´æ•°ï¼‰
    - line_end: é—®é¢˜ç»“æŸè¡Œå·ï¼ˆæ•´æ•°ï¼‰
    - description: é—®é¢˜æè¿°
    - suggestion: ä¿®å¤å»ºè®®

    å¦‚æœæ²¡æœ‰å‘ç°é—®é¢˜ï¼Œè¿”å›ç©ºæ•°ç»„ []

    ç¤ºä¾‹è¾“å‡ºï¼š
    ```json
    [
        {
            "rule_id": "backend_006",
            "severity": "warning",
            "line_start": 15,
            "line_end": 32,
            "description": "å‘ç°å¤æ‚çš„ if-else åµŒå¥—",
            "suggestion": "å»ºè®®å°†å†…å±‚é€»è¾‘æŠ½å–ä¸ºç‹¬ç«‹æ–¹æ³•"
        }
    ]
    ```
    """

def check_code_chunk(self, code: str, rules: List[Rule]) -> List[Issue]:
    """è°ƒç”¨ LLM æ£€æŸ¥ä»£ç å—"""
    # æ ¼å¼åŒ–è§„åˆ™
    rules_text = self._format_rules(rules)

    # è°ƒç”¨ LLM
    response = self.llm.chat_oai(
        conversations=[{
            "role": "user",
            "content": self.check_code_prompt(code, rules_text)
        }]
    )[0].output

    # è§£æ JSON
    issues = self._parse_llm_response(response)

    return issues
```

#### check_files_concurrent() - å¹¶å‘æ£€æŸ¥

```python
def check_files_concurrent(
    self, files: List[str], max_workers: int = 5
) -> Generator[FileCheckResult, None, None]:
    """
    å¹¶å‘æ£€æŸ¥å¤šä¸ªæ–‡ä»¶

    ä½¿ç”¨ ThreadPoolExecutor å®ç°å¹¶å‘æ£€æŸ¥ï¼Œæé«˜å¤§å‹é¡¹ç›®çš„æ£€æŸ¥é€Ÿåº¦ã€‚
    ä½¿ç”¨ç”Ÿæˆå™¨æ¨¡å¼æŒ‰å®Œæˆé¡ºåºå®æ—¶è¿”å›ç»“æœï¼Œé€‚åˆä¸è¿›åº¦æ¡é…åˆä½¿ç”¨ã€‚

    Args:
        files: æ–‡ä»¶åˆ—è¡¨
        max_workers: æœ€å¤§å¹¶å‘æ•°

    Yields:
        FileCheckResult: æŒ‰å®Œæˆé¡ºåºè¿”å›æ£€æŸ¥ç»“æœ
    """
    logger.info(f"å¼€å§‹å¹¶å‘æ£€æŸ¥ {len(files)} ä¸ªæ–‡ä»¶ (workers={max_workers})")

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡
        future_to_file = {
            executor.submit(self.check_file, file_path): file_path
            for file_path in files
        }

        # æŒ‰å®Œæˆé¡ºåºè¿”å›ç»“æœ
        for future in as_completed(future_to_file):
            file_path = future_to_file[future]
            try:
                result = future.result()
                yield result
            except Exception as exc:
                logger.error(f"æ–‡ä»¶ {file_path} æ£€æŸ¥å¤±è´¥: {exc}")
                yield FileCheckResult(
                    file_path=file_path,
                    check_time=datetime.now().isoformat(),
                    issues=[],
                    error_count=0,
                    warning_count=0,
                    info_count=0,
                    status="failed",
                    error_message=str(exc)
                )
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒè‡ªå®šä¹‰ Prompt æ¨¡æ¿
- æ”¯æŒå¤šæ¨¡å‹å¯¹æ¯”æ£€æŸ¥
- æ”¯æŒå¢é‡æ£€æŸ¥ä¼˜åŒ–
- æ”¯æŒæ£€æŸ¥ç»“æœç¼“å­˜

---

### 5. progress_tracker.py - è¿›åº¦è·Ÿè¸ªå™¨

**ä½ç½®**ï¼š`autocoder/checker/progress_tracker.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- è·Ÿè¸ªæ£€æŸ¥è¿›åº¦
- æŒä¹…åŒ–æ£€æŸ¥çŠ¶æ€
- æ”¯æŒä¸­æ–­æ¢å¤

**å…³é”®æ–¹æ³•**ï¼š

#### start_check() - å¼€å§‹æ£€æŸ¥

```python
def start_check(self, files: List[str], config: Dict[str, Any]) -> str:
    """
    å¼€å§‹æ–°çš„æ£€æŸ¥ï¼Œè¿”å› check_id

    Args:
        files: æ–‡ä»¶åˆ—è¡¨
        config: æ£€æŸ¥é…ç½®

    Returns:
        check_id: æ ¼å¼ä¸º {project}_{timestamp}
    """
    # ç”Ÿæˆ check_id
    project_name = os.path.basename(os.getcwd())
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    check_id = f"{project_name}_{timestamp}"

    # åˆ›å»ºæ£€æŸ¥çŠ¶æ€
    state = CheckState(
        check_id=check_id,
        start_time=datetime.now().isoformat(),
        config=config,
        total_files=files,
        completed_files=[],
        remaining_files=files
    )

    # ä¿å­˜çŠ¶æ€
    self.save_state(check_id, state)

    return check_id
```

#### mark_completed() - æ ‡è®°å®Œæˆ

```python
def mark_completed(self, check_id: str, file_path: str) -> None:
    """æ ‡è®°æ–‡ä»¶å·²å®Œæˆæ£€æŸ¥"""
    # åŠ è½½çŠ¶æ€
    state = self.load_state(check_id)

    # æ›´æ–°çŠ¶æ€
    if file_path in state.remaining_files:
        state.remaining_files.remove(file_path)

    if file_path not in state.completed_files:
        state.completed_files.append(file_path)

    # ä¿å­˜çŠ¶æ€
    self.save_state(check_id, state)
```

#### resume_check() - æ¢å¤æ£€æŸ¥

```python
def get_remaining_files(self, check_id: str) -> List[str]:
    """è·å–å¾…æ£€æŸ¥çš„æ–‡ä»¶åˆ—è¡¨"""
    state = self.load_state(check_id)
    return state.remaining_files if state else []
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒæ£€æŸ¥å†å²ç®¡ç†
- æ”¯æŒæ£€æŸ¥ç»Ÿè®¡åˆ†æ
- æ”¯æŒå¤šç”¨æˆ·æ£€æŸ¥éš”ç¦»
- æ”¯æŒåˆ†å¸ƒå¼æ£€æŸ¥åè°ƒ

---

### 6. report_generator.py - æŠ¥å‘Šç”Ÿæˆå™¨

**ä½ç½®**ï¼š`autocoder/checker/report_generator.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- ç”Ÿæˆ JSON æ ¼å¼æŠ¥å‘Š
- ç”Ÿæˆ Markdown æ ¼å¼æŠ¥å‘Š
- ç”Ÿæˆæ±‡æ€»ç»Ÿè®¡

**å…³é”®æ–¹æ³•**ï¼š

#### generate_file_report() - ç”Ÿæˆæ–‡ä»¶æŠ¥å‘Š

```python
def generate_file_report(self, result: FileCheckResult, report_dir: str) -> None:
    """ç”Ÿæˆå•ä¸ªæ–‡ä»¶çš„æ£€æŸ¥æŠ¥å‘Š"""
    # åˆ›å»ºæŠ¥å‘Šç›®å½•
    files_dir = os.path.join(report_dir, "files")
    os.makedirs(files_dir, exist_ok=True)

    # ç”Ÿæˆæ–‡ä»¶åï¼ˆæ›¿æ¢è·¯å¾„åˆ†éš”ç¬¦ï¼‰
    safe_filename = result.file_path.replace("/", "_").replace("\\", "_")

    # ç”Ÿæˆ JSON æŠ¥å‘Š
    json_path = os.path.join(files_dir, f"{safe_filename}.json")
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(result.dict(), f, indent=2, ensure_ascii=False)

    # ç”Ÿæˆ Markdown æŠ¥å‘Š
    md_path = os.path.join(files_dir, f"{safe_filename}.md")
    md_content = self._generate_file_markdown(result)
    with open(md_path, 'w', encoding='utf-8') as f:
        f.write(md_content)
```

#### generate_summary_report() - ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š

```python
def generate_summary_report(
    self, results: List[FileCheckResult], report_dir: str
) -> None:
    """ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š"""
    # ç»Ÿè®¡ä¿¡æ¯
    total_files = len(results)
    total_issues = sum(len(r.issues) for r in results)
    total_errors = sum(r.error_count for r in results)
    total_warnings = sum(r.warning_count for r in results)
    total_infos = sum(r.info_count for r in results)

    # é—®é¢˜æœ€å¤šçš„æ–‡ä»¶
    top_files = sorted(
        results,
        key=lambda r: len(r.issues),
        reverse=True
    )[:10]

    # æŒ‰è§„åˆ™åˆ†ç±»
    rule_counts = {}
    for result in results:
        for issue in result.issues:
            rule_counts[issue.rule_id] = rule_counts.get(issue.rule_id, 0) + 1

    # ç”Ÿæˆæ±‡æ€»æ•°æ®
    summary = {
        "check_id": os.path.basename(report_dir),
        "total_files": total_files,
        "total_issues": total_issues,
        "error_count": total_errors,
        "warning_count": total_warnings,
        "info_count": total_infos,
        "top_files": [
            {"file": f.file_path, "issues": len(f.issues)}
            for f in top_files
        ],
        "rule_distribution": rule_counts
    }

    # ä¿å­˜ JSON
    with open(os.path.join(report_dir, "summary.json"), 'w') as f:
        json.dump(summary, f, indent=2, ensure_ascii=False)

    # ä¿å­˜ Markdown
    md_content = self._generate_summary_markdown(summary, results)
    with open(os.path.join(report_dir, "summary.md"), 'w') as f:
        f.write(md_content)
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒ HTML æŠ¥å‘Š
- æ”¯æŒ PDF å¯¼å‡º
- æ”¯æŒè¶‹åŠ¿åˆ†æï¼ˆå¤šæ¬¡æ£€æŸ¥å¯¹æ¯”ï¼‰
- æ”¯æŒè‡ªå®šä¹‰æŠ¥å‘Šæ¨¡æ¿

---

## æ’ä»¶ç³»ç»Ÿ

### CodeCheckerPlugin

**ä½ç½®**ï¼š`autocoder/plugins/code_checker_plugin.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- æ³¨å†Œ `/check` å‘½ä»¤åŠå­å‘½ä»¤
- æä¾›å‘½ä»¤è¡¥å…¨
- å‚æ•°è§£æå’ŒéªŒè¯
- è°ƒç”¨æ ¸å¿ƒæ£€æŸ¥é€»è¾‘

**æ’ä»¶ç»“æ„**ï¼š

```python
class CodeCheckerPlugin(Plugin):
    name = "code_checker"
    description = "ä»£ç è§„èŒƒæ£€æŸ¥æ’ä»¶"
    version = "1.0.0"

    def initialize(self) -> bool:
        """åˆå§‹åŒ–æ’ä»¶"""
        # åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
        self.checker = CodeChecker(self.llm, self.args)
        self.report_generator = ReportGenerator()
        self.progress_tracker = ProgressTracker()

        return True

    def get_commands(self):
        """æ³¨å†Œå‘½ä»¤"""
        return {
            "check": (self.handle_check, "ä»£ç æ£€æŸ¥å‘½ä»¤"),
        }

    def get_completions(self):
        """æä¾›å‘½ä»¤è¡¥å…¨"""
        return {
            "/check": ["/file", "/folder", "/resume", "/report"],
            "/check /folder": ["/path", "/ext", "/ignore", "/workers"],
        }
```

**å‘½ä»¤å¤„ç†**ï¼š

```python
def handle_check(self, args: str):
    """å¤„ç† /check å‘½ä»¤"""
    parts = args.strip().split(maxsplit=1)

    if not parts:
        print(self._show_help())
        return

    subcommand = parts[0]

    if subcommand == "/file":
        self._check_file(parts[1] if len(parts) > 1 else "")
    elif subcommand == "/folder":
        self._check_folder(parts[1] if len(parts) > 1 else "")
    elif subcommand == "/resume":
        self._resume_check(parts[1] if len(parts) > 1 else "")
    else:
        print(f"æœªçŸ¥å­å‘½ä»¤: {subcommand}")
        print(self._show_help())
```

**æ‰©å±•æ’ä»¶**ï¼š

1. **åˆ›å»ºæ–°æ’ä»¶**ï¼š
   ```python
   class MyCheckerPlugin(CodeCheckerPlugin):
       name = "my_checker"

       def initialize(self):
           super().initialize()
           # è‡ªå®šä¹‰åˆå§‹åŒ–
           return True

       def get_commands(self):
           commands = super().get_commands()
           # æ·»åŠ æ–°å‘½ä»¤
           commands["mycheck"] = (self.handle_mycheck, "æˆ‘çš„æ£€æŸ¥")
           return commands
   ```

2. **æ³¨å†Œæ’ä»¶**ï¼š
   åœ¨ `autocoder/plugins/__init__.py` ä¸­æ³¨å†Œ

---

## æ·»åŠ æ–°è§„åˆ™

### è§„åˆ™æ–‡ä»¶æ ¼å¼

è§„åˆ™æ–‡ä»¶ä½¿ç”¨ Markdown æ ¼å¼ï¼Œä¾¿äºé˜…è¯»å’Œç»´æŠ¤ã€‚

**æ–‡ä»¶ä½ç½®**ï¼š
- åç«¯è§„åˆ™ï¼š`rules/backend_rules.md`
- å‰ç«¯è§„åˆ™ï¼š`rules/frontend_rules.md`

**è§„åˆ™æ ¼å¼**ï¼š

```markdown
## è§„åˆ™ç±»åˆ«åç§°

### è§„åˆ™ID: backend_xxx
**æ ‡é¢˜**: è§„åˆ™æ ‡é¢˜
**ä¸¥é‡ç¨‹åº¦**: warning
**æè¿°**: è§„åˆ™çš„è¯¦ç»†æè¿°ï¼Œè¯´æ˜ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªè§„åˆ™

**é”™è¯¯ç¤ºä¾‹**:
```python
# é”™è¯¯çš„ä»£ç ç¤ºä¾‹
def bad_example():
    # è¿åè§„åˆ™çš„ä»£ç 
    pass
```

**æ­£ç¡®ç¤ºä¾‹**:
```python
# æ­£ç¡®çš„ä»£ç ç¤ºä¾‹
def good_example():
    # ç¬¦åˆè§„åˆ™çš„ä»£ç 
    pass
```
```

### æ·»åŠ æ–°è§„åˆ™æ­¥éª¤

1. **ç¼–è¾‘è§„åˆ™æ–‡ä»¶**

   ```bash
   vim rules/backend_rules.md
   ```

2. **æ·»åŠ è§„åˆ™**

   ```markdown
   ## æ€§èƒ½ä¼˜åŒ–

   ### è§„åˆ™ID: backend_100
   **æ ‡é¢˜**: é¿å…åœ¨å¾ªç¯ä¸­è¿›è¡Œæ•°æ®åº“æŸ¥è¯¢
   **ä¸¥é‡ç¨‹åº¦**: error
   **æè¿°**: åœ¨å¾ªç¯ä¸­è¿›è¡Œæ•°æ®åº“æŸ¥è¯¢ä¼šå¯¼è‡´ N+1 é—®é¢˜ï¼Œä¸¥é‡å½±å“æ€§èƒ½ã€‚åº”è¯¥ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢æˆ– JOIN ä¼˜åŒ–ã€‚

   **é”™è¯¯ç¤ºä¾‹**:
   ```python
   def get_user_posts(user_ids):
       posts = []
       for user_id in user_ids:
           # æ¯æ¬¡å¾ªç¯éƒ½æŸ¥è¯¢æ•°æ®åº“
           user_posts = db.query(Post).filter(Post.user_id == user_id).all()
           posts.extend(user_posts)
       return posts
   ```

   **æ­£ç¡®ç¤ºä¾‹**:
   ```python
   def get_user_posts(user_ids):
       # æ‰¹é‡æŸ¥è¯¢
       posts = db.query(Post).filter(Post.user_id.in_(user_ids)).all()
       return posts
   ```
   ```

3. **æ›´æ–°è§„åˆ™é…ç½®**ï¼ˆå¯é€‰ï¼‰

   å¦‚æœéœ€è¦ç‰¹æ®Šé…ç½®ï¼Œç¼–è¾‘ `rules/rules_config.json`ï¼š

   ```json
   {
     "rule_sets": {
       "backend": {
         "enabled": true,
         "disabled_rules": []  // å¦‚éœ€ç¦ç”¨æŸè§„åˆ™ï¼Œæ·»åŠ åˆ°è¿™é‡Œ
       }
     }
   }
   ```

4. **æµ‹è¯•è§„åˆ™**

   ```bash
   # å¯åŠ¨ chat_auto_coder
   python -m autocoder.chat_auto_coder

   # æµ‹è¯•æ–°è§„åˆ™
   /check /file test_file.py
   ```

5. **éªŒè¯ç»“æœ**

   æ£€æŸ¥ç”Ÿæˆçš„æŠ¥å‘Šï¼Œç¡®è®¤æ–°è§„åˆ™æ­£ç¡®ç”Ÿæ•ˆ

### è§„åˆ™æœ€ä½³å®è·µ

1. **è§„åˆ™IDè§„èŒƒ**
   - åç«¯ï¼š`backend_001` - `backend_999`
   - å‰ç«¯ï¼š`frontend_001` - `frontend_999`
   - æŒ‰ç±»åˆ«åˆ†æ®µï¼ˆå¦‚ 001-099 ä»£ç ç»“æ„ï¼Œ100-199 æ€§èƒ½ä¼˜åŒ–ï¼‰

2. **ä¸¥é‡ç¨‹åº¦é€‰æ‹©**
   - `error`ï¼šå¿…é¡»ä¿®å¤çš„é—®é¢˜ï¼ˆå®‰å…¨ã€è‡´å‘½bugï¼‰
   - `warning`ï¼šå»ºè®®ä¿®å¤çš„é—®é¢˜ï¼ˆæ€§èƒ½ã€è§„èŒƒï¼‰
   - `info`ï¼šæç¤ºæ€§ä¿¡æ¯ï¼ˆä¼˜åŒ–å»ºè®®ï¼‰

3. **æè¿°ç¼–å†™**
   - è¯´æ˜"ä¸ºä»€ä¹ˆ"è€Œä¸åªæ˜¯"æ˜¯ä»€ä¹ˆ"
   - æä¾›å…·ä½“çš„ä¿®å¤å»ºè®®
   - åŒ…å«æ­£åç¤ºä¾‹

4. **ç¤ºä¾‹ä»£ç **
   - ä½¿ç”¨å®é™…åœºæ™¯çš„ä»£ç 
   - ç¤ºä¾‹ç®€æ´æ˜äº†
   - çªå‡ºå…³é”®é—®é¢˜

---

## æ‰©å±•æ–°åŠŸèƒ½

### 1. æ·»åŠ æ–°çš„æ£€æŸ¥ç±»å‹

å‡è®¾è¦æ·»åŠ  SQL æ£€æŸ¥ï¼š

**æ­¥éª¤ 1ï¼šåˆ›å»ºè§„åˆ™æ–‡ä»¶**

```bash
# åˆ›å»º SQL è§„åˆ™æ–‡ä»¶
vim rules/sql_rules.md
```

**æ­¥éª¤ 2ï¼šç¼–å†™è§„åˆ™**

```markdown
## SQL è§„èŒƒ

### è§„åˆ™ID: sql_001
**æ ‡é¢˜**: é¿å…ä½¿ç”¨ SELECT *
**ä¸¥é‡ç¨‹åº¦**: warning
**æè¿°**: SELECT * ä¼šæŸ¥è¯¢æ‰€æœ‰å­—æ®µï¼Œå½±å“æ€§èƒ½ï¼Œä¸”åœ¨è¡¨ç»“æ„å˜æ›´æ—¶å¯èƒ½å¯¼è‡´é—®é¢˜

**é”™è¯¯ç¤ºä¾‹**:
```sql
SELECT * FROM users WHERE id = 1;
```

**æ­£ç¡®ç¤ºä¾‹**:
```sql
SELECT id, name, email FROM users WHERE id = 1;
```
```

**æ­¥éª¤ 3ï¼šæ›´æ–°é…ç½®**

ç¼–è¾‘ `rules/rules_config.json`ï¼š

```json
{
  "rule_sets": {
    "backend": { ... },
    "frontend": { ... },
    "sql": {
      "enabled": true,
      "file_patterns": ["**/*.sql"],
      "severity_threshold": "warning",
      "disabled_rules": []
    }
  }
}
```

**æ­¥éª¤ 4ï¼šæ›´æ–° RulesLoader**

åœ¨ `autocoder/checker/rules_loader.py` ä¸­æ·»åŠ ï¼š

```python
def get_applicable_rules(self, file_path: str) -> List[Rule]:
    """æ ¹æ®æ–‡ä»¶è·¯å¾„è·å–é€‚ç”¨çš„è§„åˆ™"""
    ext = os.path.splitext(file_path)[1].lower()

    # ç°æœ‰æ˜ å°„
    if ext == ".py":
        return self.load_rules("backend")
    elif ext in [".js", ".jsx", ".ts", ".tsx", ".vue"]:
        return self.load_rules("frontend")
    elif ext == ".sql":  # æ–°å¢
        return self.load_rules("sql")

    return []
```

### 2. æ·»åŠ è‡ªå®šä¹‰æŠ¥å‘Šæ ¼å¼

å‡è®¾è¦æ·»åŠ  HTML æŠ¥å‘Šï¼š

**æ­¥éª¤ 1ï¼šåˆ›å»ºæŠ¥å‘Šç”Ÿæˆæ–¹æ³•**

åœ¨ `autocoder/checker/report_generator.py` ä¸­æ·»åŠ ï¼š

```python
def generate_html_report(
    self, results: List[FileCheckResult], report_dir: str
) -> None:
    """ç”Ÿæˆ HTML æ ¼å¼æŠ¥å‘Š"""
    # HTML æ¨¡æ¿
    html_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>ä»£ç æ£€æŸ¥æŠ¥å‘Š</title>
        <style>
            /* CSS æ ·å¼ */
        </style>
    </head>
    <body>
        <h1>ä»£ç æ£€æŸ¥æŠ¥å‘Š</h1>
        {content}
    </body>
    </html>
    """

    # ç”Ÿæˆå†…å®¹
    content = self._generate_html_content(results)

    # ä¿å­˜æ–‡ä»¶
    html_path = os.path.join(report_dir, "report.html")
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_template.format(content=content))
```

**æ­¥éª¤ 2ï¼šè°ƒç”¨ç”Ÿæˆæ–¹æ³•**

åœ¨æ’ä»¶ä¸­è°ƒç”¨ï¼š

```python
def _check_folder(self, args: str):
    # ... æ£€æŸ¥é€»è¾‘ ...

    # ç”ŸæˆæŠ¥å‘Š
    self.report_generator.generate_summary_report(results, report_dir)
    self.report_generator.generate_html_report(results, report_dir)  # æ–°å¢
```

### 3. é›†æˆå¤–éƒ¨æ£€æŸ¥å·¥å…·

å‡è®¾è¦é›†æˆ Pylintï¼š

**æ­¥éª¤ 1ï¼šåˆ›å»ºå·¥å…·åŒ…è£…å™¨**

```python
# autocoder/checker/tools/pylint_wrapper.py

import subprocess
import json
from typing import List
from ..types import Issue, Severity

class PylintWrapper:
    def check(self, file_path: str) -> List[Issue]:
        """ä½¿ç”¨ Pylint æ£€æŸ¥æ–‡ä»¶"""
        # è¿è¡Œ Pylint
        result = subprocess.run(
            ["pylint", "--output-format=json", file_path],
            capture_output=True,
            text=True
        )

        # è§£æç»“æœ
        pylint_issues = json.loads(result.stdout)

        # è½¬æ¢ä¸º Issue å¯¹è±¡
        issues = []
        for item in pylint_issues:
            issues.append(Issue(
                rule_id=f"pylint_{item['message-id']}",
                severity=self._map_severity(item['type']),
                line_start=item['line'],
                line_end=item['line'],
                description=item['message'],
                suggestion=item.get('hint', ''),
                code_snippet=''
            ))

        return issues

    def _map_severity(self, pylint_type: str) -> Severity:
        """æ˜ å°„ Pylint ä¸¥é‡ç¨‹åº¦"""
        mapping = {
            'error': Severity.ERROR,
            'warning': Severity.WARNING,
            'convention': Severity.INFO,
            'refactor': Severity.INFO,
        }
        return mapping.get(pylint_type, Severity.INFO)
```

**æ­¥éª¤ 2ï¼šé›†æˆåˆ°æ£€æŸ¥æµç¨‹**

åœ¨ `core.py` ä¸­ï¼š

```python
def check_file(self, file_path: str) -> FileCheckResult:
    """æ£€æŸ¥å•ä¸ªæ–‡ä»¶"""
    # LLM æ£€æŸ¥
    llm_issues = self._check_with_llm(file_path)

    # Pylint æ£€æŸ¥ï¼ˆå¯é€‰ï¼‰
    if self.enable_pylint and file_path.endswith('.py'):
        pylint = PylintWrapper()
        pylint_issues = pylint.check(file_path)
        llm_issues.extend(pylint_issues)

    # åˆå¹¶ç»“æœ
    merged_issues = self._merge_duplicate_issues(llm_issues)

    # ... è¿”å›ç»“æœ
```

---

## API å‚è€ƒ

### CodeChecker

```python
class CodeChecker:
    def __init__(self, llm: byzerllm.ByzerLLM, args: AutoCoderArgs)

    def check_file(self, file_path: str) -> FileCheckResult
        """æ£€æŸ¥å•ä¸ªæ–‡ä»¶"""

    def check_files_concurrent(
        self, files: List[str], max_workers: int = 5
    ) -> Generator[FileCheckResult, None, None]
        """å¹¶å‘æ£€æŸ¥å¤šä¸ªæ–‡ä»¶"""

    def check_code_chunk(
        self, code: str, rules: List[Rule]
    ) -> List[Issue]
        """æ£€æŸ¥ä»£ç å—"""
```

### RulesLoader

```python
class RulesLoader:
    def __init__(self, rules_dir: str = "rules")

    def load_rules(self, rule_type: str) -> List[Rule]
        """åŠ è½½æŒ‡å®šç±»å‹çš„è§„åˆ™"""

    def get_applicable_rules(self, file_path: str) -> List[Rule]
        """æ ¹æ®æ–‡ä»¶è·¯å¾„è·å–é€‚ç”¨çš„è§„åˆ™"""

    def reload_rules(self) -> None
        """é‡æ–°åŠ è½½æ‰€æœ‰è§„åˆ™"""
```

### FileProcessor

```python
class FileProcessor:
    def __init__(self, chunk_size: int = 4000, overlap: int = 200)

    def scan_files(self, path: str, filters: FileFilters) -> List[str]
        """æ‰«æç›®å½•ï¼Œè¿”å›ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶åˆ—è¡¨"""

    def chunk_file(self, file_path: str) -> List[CodeChunk]
        """å°†å¤§æ–‡ä»¶åˆ†å—"""

    def is_checkable(self, file_path: str) -> bool
        """åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å¯æ£€æŸ¥"""
```

### ProgressTracker

```python
class ProgressTracker:
    def __init__(self, state_dir: str = ".auto-coder/codecheck/progress")

    def start_check(self, files: List[str], config: Dict) -> str
        """å¼€å§‹æ–°çš„æ£€æŸ¥ï¼Œè¿”å› check_id"""

    def mark_completed(self, check_id: str, file_path: str) -> None
        """æ ‡è®°æ–‡ä»¶å·²å®Œæˆæ£€æŸ¥"""

    def get_remaining_files(self, check_id: str) -> List[str]
        """è·å–å¾…æ£€æŸ¥çš„æ–‡ä»¶åˆ—è¡¨"""

    def save_state(self, check_id: str, state: CheckState) -> None
        """ä¿å­˜æ£€æŸ¥çŠ¶æ€"""

    def load_state(self, check_id: str) -> Optional[CheckState]
        """åŠ è½½æ£€æŸ¥çŠ¶æ€"""
```

### ReportGenerator

```python
class ReportGenerator:
    def __init__(self, output_dir: str = "codecheck")

    def generate_file_report(
        self, result: FileCheckResult, report_dir: str
    ) -> None
        """ç”Ÿæˆå•ä¸ªæ–‡ä»¶çš„æ£€æŸ¥æŠ¥å‘Š"""

    def generate_summary_report(
        self, results: List[FileCheckResult], report_dir: str
    ) -> None
        """ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š"""
```

---

## æµ‹è¯•æŒ‡å—

### å•å…ƒæµ‹è¯•

**æµ‹è¯•æ–‡ä»¶ä½ç½®**ï¼š`tests/checker/`

**æµ‹è¯•ç¤ºä¾‹**ï¼š

```python
# tests/checker/test_rules_loader.py

import pytest
from autocoder.checker.rules_loader import RulesLoader
from autocoder.checker.types import Rule, Severity

def test_load_backend_rules():
    """æµ‹è¯•åŠ è½½åç«¯è§„åˆ™"""
    loader = RulesLoader()
    rules = loader.load_rules("backend")

    assert len(rules) > 0
    assert all(isinstance(r, Rule) for r in rules)
    assert all(r.id.startswith("backend_") for r in rules)

def test_get_applicable_rules_for_python():
    """æµ‹è¯• Python æ–‡ä»¶è§„åˆ™é€‰æ‹©"""
    loader = RulesLoader()
    rules = loader.get_applicable_rules("test.py")

    assert len(rules) > 0
    assert all(r.id.startswith("backend_") for r in rules)

def test_rule_caching():
    """æµ‹è¯•è§„åˆ™ç¼“å­˜"""
    loader = RulesLoader()

    rules1 = loader.load_rules("backend")
    rules2 = loader.load_rules("backend")

    # åº”è¯¥è¿”å›åŒä¸€ä¸ªå¯¹è±¡ï¼ˆç¼“å­˜ï¼‰
    assert rules1 is rules2
```

**è¿è¡Œæµ‹è¯•**ï¼š

```bash
# è¿è¡Œæ‰€æœ‰æ£€æŸ¥å™¨æµ‹è¯•
pytest tests/checker/ -v

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
pytest tests/checker/test_rules_loader.py -v

# æŸ¥çœ‹è¦†ç›–ç‡
pytest tests/checker/ --cov=autocoder/checker --cov-report=html
```

### é›†æˆæµ‹è¯•

```python
# tests/checker/test_integration.py

def test_full_check_workflow():
    """æµ‹è¯•å®Œæ•´çš„æ£€æŸ¥æµç¨‹"""
    # 1. åˆ›å»ºä¸´æ—¶æµ‹è¯•æ–‡ä»¶
    test_file = "test_code.py"
    with open(test_file, 'w') as f:
        f.write("""
def test_function():
    if True:
        if True:
            if True:
                if True:
                    pass  # åµŒå¥—è¿‡æ·±
        """)

    try:
        # 2. åˆå§‹åŒ–æ£€æŸ¥å™¨
        checker = CodeChecker(mock_llm, mock_args)

        # 3. æ‰§è¡Œæ£€æŸ¥
        result = checker.check_file(test_file)

        # 4. éªŒè¯ç»“æœ
        assert result.status == "success"
        assert len(result.issues) > 0

        # 5. éªŒè¯æŠ¥å‘Šç”Ÿæˆ
        report_gen = ReportGenerator()
        report_gen.generate_file_report(result, "test_reports")

        assert os.path.exists("test_reports/files/test_code_py.json")
        assert os.path.exists("test_reports/files/test_code_py.md")

    finally:
        # æ¸…ç†
        os.remove(test_file)
        shutil.rmtree("test_reports")
```

### Mock æµ‹è¯•

```python
from unittest.mock import Mock, patch

def test_check_with_mock_llm():
    """ä½¿ç”¨ Mock LLM æµ‹è¯•"""
    # Mock LLM è¿”å›
    mock_llm = Mock()
    mock_llm.chat_oai.return_value = [Mock(output="""
    ```json
    [
        {
            "rule_id": "backend_001",
            "severity": "error",
            "line_start": 10,
            "line_end": 15,
            "description": "æµ‹è¯•é—®é¢˜",
            "suggestion": "æµ‹è¯•å»ºè®®"
        }
    ]
    ```
    """)]

    # æ‰§è¡Œæ£€æŸ¥
    checker = CodeChecker(mock_llm, mock_args)
    result = checker.check_file("test.py")

    # éªŒè¯
    assert result.status == "success"
    assert len(result.issues) == 1
    assert result.issues[0].rule_id == "backend_001"
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. è§„åˆ™ç¼“å­˜

```python
# ä½¿ç”¨ LRU ç¼“å­˜
from functools import lru_cache

class RulesLoader:
    @lru_cache(maxsize=10)
    def load_rules(self, rule_type: str) -> List[Rule]:
        # åŠ è½½é€»è¾‘
        pass
```

### 2. å¹¶å‘ä¼˜åŒ–

```python
# åŠ¨æ€è°ƒæ•´å¹¶å‘æ•°
def get_optimal_workers(file_count: int) -> int:
    if file_count < 10:
        return 2
    elif file_count < 50:
        return 5
    else:
        return 10
```

### 3. å¢é‡æ£€æŸ¥

```python
# åªæ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶
def get_changed_files() -> List[str]:
    result = subprocess.run(
        ["git", "diff", "--name-only", "HEAD"],
        capture_output=True,
        text=True
    )
    return result.stdout.strip().split('\n')
```

---

## å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•è°ƒè¯• LLM Promptï¼Ÿ

**A**: å¯ç”¨æ—¥å¿—è®°å½•ï¼š

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("autocoder.checker")

# æŸ¥çœ‹ LLM è¯·æ±‚å’Œå“åº”
logger.debug(f"LLM Request: {prompt}")
logger.debug(f"LLM Response: {response}")
```

### Q2: å¦‚ä½•ä¼˜åŒ–æ£€æŸ¥é€Ÿåº¦ï¼Ÿ

**A**:
1. å¢åŠ å¹¶å‘æ•°
2. å‡å°‘è§„åˆ™æ•°é‡
3. ä½¿ç”¨æ›´å¿«çš„æ¨¡å‹
4. å®ç°ç»“æœç¼“å­˜

### Q3: å¦‚ä½•å¤„ç†æ£€æŸ¥ç»“æœä¸å‡†ç¡®ï¼Ÿ

**A**:
1. ä¼˜åŒ– Prompt æ¨¡æ¿
2. æ·»åŠ æ›´å¤šç¤ºä¾‹åˆ°è§„åˆ™
3. ä½¿ç”¨æ›´å¼ºçš„æ¨¡å‹
4. ç»“åˆé™æ€åˆ†æå·¥å…·

---

## è´¡çŒ®æŒ‡å—

æ¬¢è¿è´¡çŒ®ä»£ç å’Œæ”¹è¿›å»ºè®®ï¼

### å¼€å‘æµç¨‹

1. Fork é¡¹ç›®
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯
3. ç¼–å†™ä»£ç å’Œæµ‹è¯•
4. æäº¤ Pull Request

### ä»£ç è§„èŒƒ

- éµå¾ª PEP 8
- æ·»åŠ ç±»å‹æ³¨è§£
- ç¼–å†™æ–‡æ¡£å­—ç¬¦ä¸²
- æ·»åŠ å•å…ƒæµ‹è¯•

---

## ä¿®å¤è®°å½•

### 2025-10-11: ä¿®å¤æ¨¡å‹è·å–é€»è¾‘

**é—®é¢˜æè¿°**ï¼š
ç”¨æˆ·åœ¨ä½¿ç”¨ `/check /folder` å‘½ä»¤æ—¶é‡åˆ°é”™è¯¯ï¼š
```
CodeChecker åˆå§‹åŒ–å¤±è´¥: Failed to create LLM instance for models: deepseek/deepseek-chat
- Model 'deepseek/deepseek-chat' not found
```

**é—®é¢˜åŸå› **ï¼š
åœ¨ `code_checker_plugin.py` çš„ `_ensure_checker()` æ–¹æ³•ä¸­ï¼ˆç¬¬103è¡Œï¼‰ï¼Œä»£ç ç¡¬ç¼–ç äº†ä¸€ä¸ªé»˜è®¤æ¨¡å‹ï¼š
```python
model_name = conf.get("model", "deepseek/deepseek-chat")
```

å½“é…ç½®ä¸­æ²¡æœ‰ "model" å­—æ®µæ—¶ï¼Œä¼šä½¿ç”¨è¿™ä¸ªä¸å­˜åœ¨çš„é»˜è®¤æ¨¡å‹ï¼Œå¯¼è‡´åˆå§‹åŒ–å¤±è´¥ã€‚

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
1. **æ™ºèƒ½æ¨¡å‹é€‰æ‹©**ï¼šæŒ‰ä¼˜å…ˆçº§é€‰æ‹©æ¨¡å‹
   - ä¼˜å…ˆä½¿ç”¨ `chat_model`ï¼ˆchat æ¨¡å¼ä¸“ç”¨æ¨¡å‹ï¼‰
   - å…¶æ¬¡ä½¿ç”¨ `model`ï¼ˆé€šç”¨æ¨¡å‹ï¼‰
   - æœ€åä» LLMManager ä¸­è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæœ‰ API key çš„å¯ç”¨æ¨¡å‹

2. **å‹å¥½çš„é”™è¯¯æç¤º**ï¼š
   - å½“å®Œå…¨æ²¡æœ‰å¯ç”¨æ¨¡å‹æ—¶ï¼Œæä¾›æ¸…æ™°çš„é…ç½®æŒ‡å¯¼
   - å½“æ¨¡å‹æ— æ³•åˆå§‹åŒ–æ—¶ï¼Œæç¤ºå¯èƒ½çš„åŸå› å’Œè§£å†³æ–¹æ³•

**ä¿®æ”¹æ–‡ä»¶**ï¼š
- `autocoder/plugins/code_checker_plugin.py` (ç¬¬82-139è¡Œ)

**ä¿®æ”¹å†…å®¹**ï¼š
```python
def _ensure_checker(self):
    # ... çœç•¥éƒ¨åˆ†ä»£ç  ...

    # æ™ºèƒ½è·å–æ¨¡å‹é…ç½®
    # 1. ä¼˜å…ˆä½¿ç”¨ chat_modelï¼ˆchat æ¨¡å¼ä¸“ç”¨ï¼‰
    # 2. å…¶æ¬¡ä½¿ç”¨ modelï¼ˆé€šç”¨æ¨¡å‹ï¼‰
    # 3. æœ€åå°è¯•è·å–ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å‹
    model_name = conf.get("chat_model") or conf.get("model")

    if not model_name:
        # å¦‚æœé…ç½®ä¸­æ²¡æœ‰æ¨¡å‹ï¼Œå°è¯•ä» LLMManager è·å–ç¬¬ä¸€ä¸ªæœ‰ API key çš„æ¨¡å‹
        llm_manager = LLMManager()
        all_models = llm_manager.get_all_models()

        # æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæœ‰ API key çš„æ¨¡å‹
        for name, model in all_models.items():
            if llm_manager.has_key(name):
                model_name = name
                logger.info(f"[{self.name}] é…ç½®ä¸­æœªæŒ‡å®šæ¨¡å‹ï¼Œè‡ªåŠ¨é€‰æ‹©: {model_name}")
                break

        if not model_name:
            raise RuntimeError(
                "æœªé…ç½®æ¨¡å‹ï¼Œä¸”æœªæ‰¾åˆ°å¯ç”¨çš„æ¨¡å‹\n"
                "è¯·ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ä¹‹ä¸€é…ç½®æ¨¡å‹ï¼š\n"
                "1. /models /add <model_name> <api_key> - æ·»åŠ å¹¶æ¿€æ´»æ¨¡å‹\n"
                "2. /config model <model_name> - è®¾ç½®å½“å‰ä½¿ç”¨çš„æ¨¡å‹"
            )

    # ... çœç•¥åç»­ä»£ç  ...
```

**æµ‹è¯•éªŒè¯**ï¼š
- åœºæ™¯1ï¼šé…ç½®ä¸­æœ‰ `chat_model` â†’ ä½¿ç”¨ `chat_model`
- åœºæ™¯2ï¼šé…ç½®ä¸­åªæœ‰ `model` â†’ ä½¿ç”¨ `model`
- åœºæ™¯3ï¼šé…ç½®ä¸­éƒ½æ²¡æœ‰ï¼Œä½†æœ‰å·²æ¿€æ´»çš„æ¨¡å‹ â†’ è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªæœ‰ API key çš„æ¨¡å‹
- åœºæ™¯4ï¼šæ²¡æœ‰ä»»ä½•å¯ç”¨æ¨¡å‹ â†’ æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º

**å½±å“èŒƒå›´**ï¼š
- ä»…å½±å“ CodeChecker çš„åˆå§‹åŒ–é€»è¾‘
- ä¸å½±å“ç°æœ‰åŠŸèƒ½
- å‘åå…¼å®¹

**ç›¸å…³æ–‡ä»¶**ï¼š
- `autocoder/plugins/code_checker_plugin.py`
- `autocoder/checker/core.py`

**æäº¤ä¿¡æ¯**ï¼š
```
fix(checker): æ™ºèƒ½è·å–å½“å‰æ¿€æ´»çš„æ¨¡å‹

- ä¼˜å…ˆä½¿ç”¨ chat_modelï¼Œå…¶æ¬¡ modelï¼Œæœ€åè‡ªåŠ¨é€‰æ‹©
- ç§»é™¤ç¡¬ç¼–ç çš„é»˜è®¤æ¨¡å‹ "deepseek/deepseek-chat"
- æ·»åŠ å‹å¥½çš„é”™è¯¯æç¤ºå’Œé…ç½®æŒ‡å¯¼
- ä¿®å¤ç”¨æˆ·ä½¿ç”¨ /check å‘½ä»¤æ—¶çš„æ¨¡å‹åˆå§‹åŒ–å¤±è´¥é—®é¢˜
```

---

### 2025-10-11: æ·»åŠ è§„åˆ™æ–‡ä»¶è‡ªåŠ¨åˆå§‹åŒ–åŠŸèƒ½

**é—®é¢˜æè¿°**ï¼š
ç”¨æˆ·åœ¨é¡¹ç›®ç›®å½•æ‰§è¡Œ `/check /folder` å‘½ä»¤æ—¶ï¼Œé‡åˆ°å¤§é‡æ–‡ä»¶æ£€æŸ¥å¤±è´¥ï¼ˆ102ä¸ªå¤±è´¥ï¼Œ0ä¸ªæˆåŠŸï¼‰ï¼ŒåŸå› æ˜¯å½“å‰ç›®å½•æ²¡æœ‰è§„åˆ™æ–‡ä»¶ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
åœ¨ `RulesLoader` ä¸­æ·»åŠ è‡ªåŠ¨åˆå§‹åŒ–åŠŸèƒ½ï¼Œå½“è§„åˆ™æ–‡ä»¶ä¸å­˜åœ¨æ—¶è‡ªåŠ¨ä»æ¨¡æ¿å¤åˆ¶ã€‚

**ä¸»è¦æ”¹è¿›**ï¼š

1. **æ™ºèƒ½æ¨¡æ¿æŸ¥æ‰¾**ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰ï¼š
   - æ„é€ å‡½æ•°å‚æ•° `template_rules_dir`
   - ç¯å¢ƒå˜é‡ `CODE_CHECKER_TEMPLATE_DIR`
   - é»˜è®¤ä½ç½®ï¼šé¡¹ç›®æ ¹ç›®å½• `rules/`

2. **è‡ªåŠ¨åˆå§‹åŒ–æµç¨‹**ï¼š
   - æ£€æµ‹è§„åˆ™æ–‡ä»¶ä¸å­˜åœ¨
   - æŸ¥æ‰¾æ¨¡æ¿ç›®å½•
   - éªŒè¯æ¨¡æ¿æ–‡ä»¶å®Œæ•´æ€§
   - å¤åˆ¶è§„åˆ™æ–‡ä»¶åˆ°å½“å‰ç›®å½•
   - æ˜¾ç¤ºå‹å¥½æç¤º

3. **ç”¨æˆ·å‹å¥½çš„æç¤º**ï¼š
```
âœ¨ æ£€æµ‹åˆ°å½“å‰ç›®å½•æ²¡æœ‰è§„åˆ™æ–‡ä»¶
ğŸ“‹ æ­£åœ¨ä»æ¨¡æ¿è‡ªåŠ¨åˆ›å»ºè§„åˆ™æ–‡ä»¶...
   âœ“ backend_rules.md (63æ¡åç«¯è§„åˆ™)
   âœ“ frontend_rules.md (105æ¡å‰ç«¯è§„åˆ™)
   âœ“ rules_config.json (é…ç½®æ–‡ä»¶)

âœ… è§„åˆ™æ–‡ä»¶åˆå§‹åŒ–æˆåŠŸï¼
   è§„åˆ™ç›®å½•: /path/to/current/rules
```

**ä¿®æ”¹æ–‡ä»¶**ï¼š
- `autocoder/checker/rules_loader.py`
  - ä¿®æ”¹ `__init__()` æ·»åŠ  `template_rules_dir` å’Œ `auto_init` å‚æ•°
  - ä¿®æ”¹ `load_rules()` æ·»åŠ è‡ªåŠ¨åˆå§‹åŒ–é€»è¾‘
  - æ–°å¢ `_get_template_dir()` æ–¹æ³•
  - æ–°å¢ `_auto_initialize_rules()` æ–¹æ³•

**é…ç½®æ–¹å¼**ï¼š

æ–¹å¼1ï¼šä½¿ç”¨é»˜è®¤è¡Œä¸ºï¼ˆæ¨èï¼‰
```bash
/check /folder  # è‡ªåŠ¨ä»é¡¹ç›®æ ¹ç›®å½•çš„ rules/ å¤åˆ¶
```

æ–¹å¼2ï¼šé€šè¿‡ç¯å¢ƒå˜é‡æŒ‡å®š
```bash
export CODE_CHECKER_TEMPLATE_DIR=/path/to/template/rules
/check /folder
```

æ–¹å¼3ï¼šç¦ç”¨è‡ªåŠ¨åˆå§‹åŒ–
```python
loader = RulesLoader(auto_init=False)
```

**ç‰¹æ€§**ï¼š
- âœ… é»˜è®¤å¯ç”¨ï¼Œæ— éœ€æ‰‹åŠ¨é…ç½®
- âœ… å‘åå…¼å®¹
- âœ… å‹å¥½çš„é”™è¯¯æç¤º
- âœ… æ”¯æŒå¤šç§æ¨¡æ¿è·¯å¾„é…ç½®
- âœ… é˜²æ­¢é‡å¤åˆå§‹åŒ–

**æäº¤ä¿¡æ¯**ï¼š
```
feat(checker): æ·»åŠ è§„åˆ™æ–‡ä»¶è‡ªåŠ¨åˆå§‹åŒ–åŠŸèƒ½

- å½“æ£€æµ‹åˆ°æ²¡æœ‰è§„åˆ™æ–‡ä»¶æ—¶è‡ªåŠ¨ä»æ¨¡æ¿å¤åˆ¶
- æ”¯æŒå¤šç§æ–¹å¼æŒ‡å®šæ¨¡æ¿ç›®å½•ï¼ˆå‚æ•°/ç¯å¢ƒå˜é‡/é»˜è®¤ä½ç½®ï¼‰
- æä¾›å‹å¥½çš„ç”¨æˆ·æç¤ºå’Œé”™è¯¯æŒ‡å¯¼
- è§£å†³ç”¨æˆ·åœ¨é¡¹ç›®ç›®å½•æ‰§è¡Œæ£€æŸ¥æ—¶è§„åˆ™æ–‡ä»¶ç¼ºå¤±çš„é—®é¢˜
- é»˜è®¤å¯ç”¨ï¼Œå‘åå…¼å®¹

ä¿®å¤é—®é¢˜ï¼šç”¨æˆ·æ‰§è¡Œ /check /folder æ—¶ 102 ä¸ªæ–‡ä»¶å¤±è´¥
```

---

### 2025-10-11: ä¿®å¤ LLM è°ƒç”¨è¶…æ—¶å¯¼è‡´æœ€åæ–‡ä»¶æ— æ³•å¤„ç†çš„é—®é¢˜

**é—®é¢˜æè¿°**ï¼š
åœ¨ä½¿ç”¨ `/check /folder` æˆ– `/check /resume` å‘½ä»¤è¿›è¡Œä»£ç æ£€æŸ¥æ—¶ï¼Œæœ€åä¸€ä¸ªæ–‡ä»¶ï¼ˆå¦‚ DictItemServiceImpl.javaï¼‰æ— æ³•å®Œæˆæ£€æŸ¥ï¼Œè¡¨ç°ä¸ºï¼š
1. è¿›åº¦æ¡æ˜¾ç¤º 100% ä½†æ£€æŸ¥æœªå®Œæˆ
2. æ–‡ä»¶æ£€æŸ¥ä¸€ç›´å¡ä½ï¼Œé•¿æ—¶é—´æ— å“åº”ï¼ˆ10+ åˆ†é’Ÿï¼‰
3. Resume åä»ç„¶å¡åœ¨åŒä¸€ä¸ªæ–‡ä»¶

**é—®é¢˜æ ¹å› **ï¼š
é€šè¿‡åˆ†ææ—¥å¿—å‘ç°ï¼Œæ–‡ä»¶æ£€æŸ¥å¡åœ¨ LLM API è°ƒç”¨é˜¶æ®µï¼š
- DictItemServiceImpl.java åœ¨ 03:41:57 å¼€å§‹æ£€æŸ¥ï¼Œä½†ä»æœªå®Œæˆ
- Resume æ—¶ï¼ˆ03:46:57ï¼‰å†æ¬¡å¼€å§‹æ£€æŸ¥ï¼Œä¾ç„¶å¡ä½
- ä»æ—¥å¿—æ¥çœ‹ï¼Œ`check_code_chunk()` æ–¹æ³•ä¸­çš„ `self.llm.chat_oai()` è°ƒç”¨**æ²¡æœ‰è¶…æ—¶æœºåˆ¶**ï¼Œå¯¼è‡´ï¼š
  - API è°ƒç”¨è¶…æ—¶æˆ–ç½‘ç»œä¸­æ–­æ—¶ï¼Œç¨‹åºä¸€ç›´ç­‰å¾…
  - æ— æ³•ç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªæ–‡ä»¶æˆ–ä¸‹ä¸€ä¸ª chunk
  - Resume åŠŸèƒ½ä¹Ÿæ— æ³•è§£å†³é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **ä¸º LLM è°ƒç”¨æ·»åŠ è¶…æ—¶æœºåˆ¶**ï¼š
   - ä½¿ç”¨ `ThreadPoolExecutor` åŒ…è£… LLM è°ƒç”¨
   - è®¾ç½® 180 ç§’è¶…æ—¶æ—¶é—´
   - è¶…æ—¶åè¿”å›ç©ºç»“æœï¼Œç»§ç»­å¤„ç†

2. **å¢å¼ºå¼‚å¸¸å¤„ç†å’Œæ—¥å¿—**ï¼š
   - æ·»åŠ è¯¦ç»†çš„ LLM è°ƒç”¨æ—¶é—´è®°å½•
   - è®°å½•æ¯ä¸ª chunk çš„æ£€æŸ¥è¿›åº¦
   - ç»Ÿè®¡è¶…æ—¶çš„ chunk æ•°é‡

3. **æ”¹è¿›æ–‡ä»¶çº§é”™è¯¯å¤„ç†**ï¼š
   - ç¡®ä¿å³ä½¿æŸä¸ª chunk è¶…æ—¶ï¼Œä¹Ÿèƒ½ç»§ç»­æ£€æŸ¥å…¶ä»– chunks
   - è®°å½• chunk çº§åˆ«çš„å¤±è´¥æƒ…å†µ

**ä¿®æ”¹å†…å®¹**ï¼š

åœ¨ `autocoder/checker/core.py` ä¸­ï¼š

```python
# 1. å¯¼å…¥ TimeoutError
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError

# 2. ä¿®æ”¹ check_code_chunk() æ–¹æ³•ï¼Œæ·»åŠ  timeout å‚æ•°
def check_code_chunk(
    self, code: str, rules: List[Rule], timeout: int = 180
) -> List[Issue]:
    """
    æ£€æŸ¥ä»£ç å—

    Args:
        code: ä»£ç å†…å®¹ï¼ˆå¸¦è¡Œå·ï¼‰
        rules: é€‚ç”¨çš„è§„åˆ™åˆ—è¡¨
        timeout: LLM è°ƒç”¨è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 180 ç§’
    """
    try:
        # ... å‡†å¤‡å·¥ä½œ ...

        # ä½¿ç”¨ ThreadPoolExecutor å®ç°è¶…æ—¶
        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(self._call_llm, conversations)
            try:
                response = future.result(timeout=timeout)
            except TimeoutError:
                logger.error(f"LLM è°ƒç”¨è¶…æ—¶ï¼ˆ{timeout}ç§’ï¼‰ï¼Œè·³è¿‡æ­¤ä»£ç å—")
                return []
            except Exception as e:
                logger.error(f"LLM è°ƒç”¨å¤±è´¥: {e}", exc_info=True)
                return []

        # ... å¤„ç†å“åº” ...

# 3. æ–°å¢ _call_llm() è¾…åŠ©æ–¹æ³•
def _call_llm(self, conversations: List[Dict[str, str]]) -> Any:
    """
    è°ƒç”¨ LLMï¼ˆå†…éƒ¨æ–¹æ³•ï¼Œç”¨äºæ”¯æŒè¶…æ—¶ï¼‰

    è®°å½•è°ƒç”¨å¼€å§‹/ç»“æŸæ—¶é—´ï¼Œä¾¿äºæ’æŸ¥é—®é¢˜
    """
    start_time = datetime.now()
    logger.debug(f"å¼€å§‹ LLM è°ƒç”¨: {start_time.isoformat()}")

    try:
        response = self.llm.chat_oai(conversations=conversations)

        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        logger.debug(f"LLM è°ƒç”¨å®Œæˆï¼Œè€—æ—¶: {duration:.2f}ç§’")

        return response
    except Exception as e:
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        logger.error(f"LLM è°ƒç”¨å¼‚å¸¸ï¼ˆè€—æ—¶ {duration:.2f}ç§’ï¼‰: {e}", exc_info=True)
        raise

# 4. æ”¹è¿› check_file() ä¸­çš„ chunk å¤„ç†
for chunk in chunks:
    logger.info(
        f"æ£€æŸ¥ chunk {chunk.chunk_index + 1}/{len(chunks)}: "
        f"è¡Œ {chunk.start_line}-{chunk.end_line}"
    )

    try:
        issues = self.check_code_chunk(chunk.content, rules)
        # ... å¤„ç†ç»“æœ ...
        logger.info(f"Chunk {chunk.chunk_index + 1} å®Œæˆï¼Œå‘ç° {len(issues)} ä¸ªé—®é¢˜")
    except Exception as e:
        logger.error(f"æ£€æŸ¥ chunk {chunk.chunk_index} æ—¶å‘ç”Ÿå¼‚å¸¸: {e}", exc_info=True)
        chunk_timeout_count += 1
        continue  # ç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ª chunk

# è®°å½•è¶…æ—¶æƒ…å†µ
if chunk_timeout_count > 0:
    logger.warning(
        f"æ–‡ä»¶ {file_path} æœ‰ {chunk_timeout_count}/{len(chunks)} "
        f"ä¸ª chunk æ£€æŸ¥å¤±è´¥æˆ–è¶…æ—¶"
    )
```

**æµ‹è¯•éªŒè¯**ï¼š
- âœ… ä»£ç è¯­æ³•éªŒè¯é€šè¿‡
- âœ… æ¨¡å—å¯¼å…¥æˆåŠŸ
- âœ… æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆ18 ä¸ªæµ‹è¯•ï¼‰

**ä¿®å¤æ•ˆæœ**ï¼š
1. **LLM è°ƒç”¨è¶…æ—¶åè‡ªåŠ¨å¤±è´¥å¹¶ç»§ç»­**ï¼šä¸å†å¡ä½æ•´ä¸ªæ£€æŸ¥æµç¨‹
2. **Resume åŠŸèƒ½æ­£å¸¸**ï¼šå¤±è´¥çš„æ–‡ä»¶ä¼šè¢«æ ‡è®°ä¸ºå·²å¤„ç†ï¼Œä¸ä¼šé‡å¤å¡ä½
3. **æ˜ç¡®çš„è¶…æ—¶æ—¥å¿—**ï¼šä¾¿äºç”¨æˆ·äº†è§£é—®é¢˜åŸå› 
4. **éƒ¨åˆ†æˆåŠŸå¤„ç†**ï¼šå¦‚æœæ–‡ä»¶æœ‰å¤šä¸ª chunksï¼Œéƒ¨åˆ†è¶…æ—¶ä¸å½±å“å…¶ä»– chunks

**å½±å“èŒƒå›´**ï¼š
- ä¿®æ”¹äº† `CodeChecker.check_code_chunk()` æ–¹æ³•ç­¾åï¼ˆæ–°å¢å¯é€‰å‚æ•°ï¼‰
- æ–°å¢äº† `CodeChecker._call_llm()` è¾…åŠ©æ–¹æ³•
- å‘åå…¼å®¹ï¼šé»˜è®¤è¶…æ—¶ 180 ç§’ï¼Œå¯é€šè¿‡å‚æ•°è°ƒæ•´

**ç›¸å…³æ–‡ä»¶**ï¼š
- `autocoder/checker/core.py` (ç¬¬ 19, 257-336 è¡Œ)

**æäº¤ä¿¡æ¯**ï¼š
```
fix(checker): ä¿®å¤ LLM è°ƒç”¨è¶…æ—¶å¯¼è‡´æœ€åæ–‡ä»¶æ— æ³•å¤„ç†çš„é—®é¢˜

é—®é¢˜æè¿°ï¼š
- æ£€æŸ¥æ—¶æœ€åä¸€ä¸ªæ–‡ä»¶ä¸€ç›´å¡ä½ï¼Œæ— æ³•å®Œæˆ
- Resume åä»ç„¶å¡åœ¨åŒä¸€ä¸ªæ–‡ä»¶
- åŸå› ï¼šLLM API è°ƒç”¨æ²¡æœ‰è¶…æ—¶æœºåˆ¶

è§£å†³æ–¹æ¡ˆï¼š
1. ä¸º LLM è°ƒç”¨æ·»åŠ  180 ç§’è¶…æ—¶æœºåˆ¶
2. è¶…æ—¶åè¿”å›ç©ºç»“æœï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª chunk/æ–‡ä»¶
3. å¢å¼ºæ—¥å¿—è®°å½•ï¼Œæ˜¾ç¤ºè°ƒç”¨è€—æ—¶å’Œè¶…æ—¶ä¿¡æ¯
4. æ”¹è¿› chunk çº§å¼‚å¸¸å¤„ç†ï¼Œç¡®ä¿éƒ¨åˆ†å¤±è´¥ä¸å½±å“æ•´ä½“

æµ‹è¯•éªŒè¯ï¼š
- æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆ18/18ï¼‰
- ä»£ç è¯­æ³•å’Œå¯¼å…¥éªŒè¯é€šè¿‡

å½±å“ï¼šå‘åå…¼å®¹ï¼Œé»˜è®¤è¶…æ—¶ 180 ç§’
```

---

### 2025-10-11: ä¿®å¤æ–‡ä»¶æ£€æŸ¥è¶…æ—¶å’ŒæŠ¥å‘Šç”Ÿæˆé—®é¢˜

**é—®é¢˜æè¿°**ï¼š
åœ¨ `/projects/codecheck` é¡¹ç›®çš„æ£€æŸ¥ä¸­å‘ç°ä¸¤ä¸ªé—®é¢˜ï¼š
1. **æœ€åä¸€ä¸ªæ–‡ä»¶å¡ä½ä¸åŠ¨**ï¼š`DictItemServiceImpl.java` (556è¡Œ) åœ¨å¹¶å‘æ£€æŸ¥æ—¶æ— æ³•å®Œæˆ
2. **æ²¡æœ‰ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š**ï¼šå³ä½¿å·²å®Œæˆ140ä¸ªæ–‡ä»¶,ä¹Ÿæ²¡æœ‰ç”Ÿæˆä»»ä½•æŠ¥å‘Š

**é—®é¢˜åˆ†æ**ï¼š

1. **å¡ä½åŸå› **ï¼š
   - è™½ç„¶ä¹‹å‰æ·»åŠ äº† chunk çº§åˆ«çš„ 180 ç§’è¶…æ—¶,ä½†**æ²¡æœ‰æ–‡ä»¶çº§åˆ«çš„è¶…æ—¶ä¿æŠ¤**
   - `DictItemServiceImpl.java` è™½ç„¶åˆ†æˆäº†å¤šä¸ª chunks,ä½†æ‰€æœ‰ chunks ç´¯è®¡æ—¶é—´è¶…è¿‡10åˆ†é’Ÿ
   - å¹¶å‘æ£€æŸ¥æ—¶,è¯¥æ–‡ä»¶çš„ `check_file()` æ–¹æ³•ä¸€ç›´é˜»å¡åœ¨çº¿ç¨‹æ± ä¸­
   - `check_files_concurrent()` çš„ `future.result()` è°ƒç”¨æ²¡æœ‰è¶…æ—¶,å¯¼è‡´æ°¸ä¹…ç­‰å¾…

2. **æŠ¥å‘Šç¼ºå¤±åŸå› **ï¼š
   - å¹¶å‘æ£€æŸ¥ä½¿ç”¨ç”Ÿæˆå™¨æ¨¡å¼,åªæœ‰å½“**æ‰€æœ‰æ–‡ä»¶éƒ½è¿”å›ç»“æœ**æ—¶æ‰ä¼šé€€å‡ºå¾ªç¯
   - ç”±äºæœ€åä¸€ä¸ªæ–‡ä»¶å¡ä½,ç”Ÿæˆå™¨æ°¸è¿œæ— æ³•å®Œæˆè¿­ä»£
   - æ’ä»¶çš„ `_check_folder()` æ–¹æ³•åœ¨ç¬¬ 177 è¡Œçš„ `for result in ...` å¾ªç¯è¢«é˜»å¡
   - æŠ¥å‘Šç”Ÿæˆä»£ç (ç¬¬ 386-394 è¡Œ)æ°¸è¿œæ— æ³•æ‰§è¡Œ

**è§£å†³æ–¹æ¡ˆ**ï¼š

#### 1. ä¸ºå•ä¸ªæ–‡ä»¶æ·»åŠ æ€»è¶…æ—¶ä¿æŠ¤

åœ¨ `autocoder/checker/core.py` ä¸­ä¿®æ”¹ `check_file()` æ–¹æ³•ï¼š

```python
def check_file(self, file_path: str, file_timeout: int = 600) -> FileCheckResult:
    """
    æ£€æŸ¥å•ä¸ªæ–‡ä»¶

    Args:
        file_path: æ–‡ä»¶è·¯å¾„
        file_timeout: å•ä¸ªæ–‡ä»¶æ£€æŸ¥çš„æœ€å¤§è¶…æ—¶æ—¶é—´(ç§’),é»˜è®¤ 600 ç§’(10åˆ†é’Ÿ)
    """
    logger.info(f"å¼€å§‹æ£€æŸ¥æ–‡ä»¶: {file_path} (è¶…æ—¶: {file_timeout}ç§’)")

    # ä½¿ç”¨ ThreadPoolExecutor å®ç°æ–‡ä»¶çº§è¶…æ—¶
    with ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(self._check_file_impl, file_path)

        try:
            result = future.result(timeout=file_timeout)
            return result

        except TimeoutError:
            logger.error(f"æ–‡ä»¶ {file_path} æ£€æŸ¥è¶…æ—¶({file_timeout}ç§’)")
            return FileCheckResult(
                file_path=file_path,
                check_time=datetime.now().isoformat(),
                issues=[],
                error_count=0,
                warning_count=0,
                info_count=0,
                status="timeout",  # æ–°å¢çŠ¶æ€
                error_message=f"æ–‡ä»¶æ£€æŸ¥è¶…æ—¶({file_timeout}ç§’)"
            )

def _check_file_impl(self, file_path: str) -> FileCheckResult:
    """æ£€æŸ¥å•ä¸ªæ–‡ä»¶çš„å†…éƒ¨å®ç°ï¼ˆç”¨äºæ”¯æŒè¶…æ—¶ï¼‰"""
    # åŸ check_file() çš„å®ç°é€»è¾‘ç§»åˆ°è¿™é‡Œ
    ...
```

**å…³é”®æ”¹è¿›**ï¼š
- å°†åŸæœ‰çš„ `check_file()` é€»è¾‘æ‹†åˆ†ä¸º `_check_file_impl()`
- ç”¨ `ThreadPoolExecutor` åŒ…è£…,å®ç°æ–‡ä»¶çº§è¶…æ—¶æ§åˆ¶
- é»˜è®¤ 600 ç§’è¶…æ—¶(å¯é…ç½®)
- è¶…æ—¶æ—¶è¿”å› `status="timeout"` çš„ç»“æœ,è€Œä¸æ˜¯é˜»å¡

#### 2. ä¸ºå¹¶å‘æ£€æŸ¥ä¼ é€’è¶…æ—¶å‚æ•°

ä¿®æ”¹ `check_files_concurrent()` æ–¹æ³•ï¼š

```python
def check_files_concurrent(
    self, files: List[str], max_workers: int = 5, file_timeout: int = 600
) -> Generator[FileCheckResult, None, None]:
    """
    å¹¶å‘æ£€æŸ¥å¤šä¸ªæ–‡ä»¶

    Args:
        file_timeout: å•ä¸ªæ–‡ä»¶æ£€æŸ¥çš„æœ€å¤§è¶…æ—¶æ—¶é—´(ç§’),é»˜è®¤ 600 ç§’(10åˆ†é’Ÿ)
    """
    logger.info(f"å¼€å§‹å¹¶å‘æ£€æŸ¥ {len(files)} ä¸ªæ–‡ä»¶ (workers={max_workers}, file_timeout={file_timeout}ç§’)")

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡(ä¼ é€’ file_timeout å‚æ•°)
        future_to_file = {
            executor.submit(self.check_file, file_path, file_timeout): file_path
            for file_path in files
        }

        # æŒ‰å®Œæˆé¡ºåºè¿”å›ç»“æœ
        for future in as_completed(future_to_file):
            file_path = future_to_file[future]
            try:
                result = future.result()  # ä¸éœ€è¦é¢å¤– timeout,check_file å†…éƒ¨å·²æœ‰
                yield result
            except Exception as exc:
                # ... å¼‚å¸¸å¤„ç†
```

**å…³é”®æ”¹è¿›**ï¼š
- å°† `file_timeout` å‚æ•°ä¼ é€’ç»™ `check_file()`
- æ¯ä¸ªæ–‡ä»¶éƒ½æœ‰ç‹¬ç«‹çš„è¶…æ—¶æ§åˆ¶
- `future.result()` ä¸éœ€è¦è®¾ç½® timeout,å› ä¸º `check_file()` å†…éƒ¨å·²ç»æœ‰è¶…æ—¶æœºåˆ¶

#### 3. ç¡®ä¿å³ä½¿æ£€æŸ¥æœªå®Œæˆä¹Ÿèƒ½ç”ŸæˆæŠ¥å‘Š

ä¿®æ”¹ `autocoder/plugins/code_checker_plugin.py` çš„ `_check_folder()` æ–¹æ³•ï¼š

```python
def _check_folder(self, args: str) -> None:
    # ... å‰ç½®ä»£ç  ...

    results = []
    check_interrupted = False

    try:
        with Progress(...) as progress:
            for result in self.checker.check_files_concurrent(files, max_workers=workers):
                results.append(result)
                # ... æ›´æ–°è¿›åº¦ ...

    except KeyboardInterrupt:
        check_interrupted = True
        # ... å¤„ç†ä¸­æ–­ ...

    finally:
        # ç¡®ä¿å³ä½¿ä¸­æ–­æˆ–å‡ºé”™ä¹Ÿç”Ÿæˆéƒ¨åˆ†æŠ¥å‘Š
        if results:
            logger.info(f"ç”Ÿæˆéƒ¨åˆ†æŠ¥å‘Šï¼Œå·²å®Œæˆ {len(results)} ä¸ªæ–‡ä»¶")

            # å¦‚æœæ˜¯æ­£å¸¸å®Œæˆï¼Œæ ‡è®°çŠ¶æ€
            if not check_interrupted:
                state = self.progress_tracker.load_state(check_id)
                if state:
                    state.status = "completed"
                    self.progress_tracker.save_state(check_id, state)

            # ç”ŸæˆæŠ¥å‘Š
            report_dir = self._create_report_dir(check_id)

            # ç”Ÿæˆå•æ–‡ä»¶æŠ¥å‘Š
            for result in results:
                self.report_generator.generate_file_report(result, report_dir)

            # ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š
            self.report_generator.generate_summary_report(results, report_dir)

            # æ˜¾ç¤ºæ±‡æ€»
            if check_interrupted:
                print(f"\nğŸ“„ å·²ç”Ÿæˆéƒ¨åˆ†æŠ¥å‘Š ({len(results)}/{len(files)} ä¸ªæ–‡ä»¶)")
                print(f"   æŠ¥å‘Šä½ç½®: {report_dir}/")
                print(f"\nğŸ’¡ ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ¢å¤æ£€æŸ¥:")
                print(f"   /check /resume {check_id}\n")
            else:
                self._show_batch_summary(results, report_dir)
```

**å…³é”®æ”¹è¿›**ï¼š
- ä½¿ç”¨ `try-finally` ç»“æ„ç¡®ä¿æŠ¥å‘Šä¸€å®šä¼šç”Ÿæˆ
- å³ä½¿ä¸­æ–­æˆ–è¶…æ—¶,å·²å®Œæˆçš„æ–‡ä»¶ä¹Ÿä¼šç”ŸæˆæŠ¥å‘Š
- åŒºåˆ†æ­£å¸¸å®Œæˆå’Œä¸­æ–­ä¸¤ç§æƒ…å†µçš„æç¤º

#### 4. å¤„ç† timeout çŠ¶æ€çš„ç»Ÿè®¡æ˜¾ç¤º

ä¿®æ”¹ `_show_batch_summary()` æ–¹æ³•ï¼š

```python
def _show_batch_summary(self, results: List, report_dir: str) -> None:
    # ç»Ÿè®¡
    total_files = len(results)
    checked_files = len([r for r in results if r.status == "success"])
    skipped_files = len([r for r in results if r.status == "skipped"])
    failed_files = len([r for r in results if r.status == "failed"])
    timeout_files = len([r for r in results if r.status == "timeout"])  # æ–°å¢

    print(f"æ£€æŸ¥æ–‡ä»¶: {total_files}")
    print(f"â”œâ”€ âœ… æˆåŠŸ: {checked_files}")
    print(f"â”œâ”€ â­ï¸  è·³è¿‡: {skipped_files}")
    print(f"â”œâ”€ â±ï¸  è¶…æ—¶: {timeout_files}")  # æ–°å¢
    print(f"â””â”€ âŒ å¤±è´¥: {failed_files}")
```

åŒæ—¶åœ¨å•æ–‡ä»¶æ£€æŸ¥ç»“æœæ˜¾ç¤ºä¸­æ·»åŠ :

```python
elif result.status == "timeout":
    print(f"â±ï¸  æ–‡ä»¶æ£€æŸ¥è¶…æ—¶: {file_path}")
    print(f"   é”™è¯¯: {result.error_message}")
```

**ä¿®æ”¹æ–‡ä»¶æ¸…å•**ï¼š
1. `autocoder/checker/core.py`
   - ä¿®æ”¹ `check_file()` æ·»åŠ æ–‡ä»¶çº§è¶…æ—¶
   - æ–°å¢ `_check_file_impl()` å®ç°æ–¹æ³•
   - ä¿®æ”¹ `check_files_concurrent()` ä¼ é€’è¶…æ—¶å‚æ•°

2. `autocoder/plugins/code_checker_plugin.py`
   - ä¿®æ”¹ `_check_folder()` ä½¿ç”¨ try-finally ç¡®ä¿æŠ¥å‘Šç”Ÿæˆ
   - ä¿®æ”¹ `_show_batch_summary()` ç»Ÿè®¡ timeout çŠ¶æ€
   - ä¿®æ”¹ `_check_file()` æ˜¾ç¤º timeout çŠ¶æ€

**æµ‹è¯•éªŒè¯**ï¼š
- âœ… æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡ (4/4 check_file ç›¸å…³æµ‹è¯•)
- âœ… ä»£ç è¯­æ³•éªŒè¯é€šè¿‡
- âœ… å‘åå…¼å®¹ï¼šé»˜è®¤è¶…æ—¶ 600 ç§’

**é¢„æœŸæ•ˆæœ**ï¼š
1. **ä¸å†å¡ä½**ï¼šæ–‡ä»¶è¶…æ—¶åè‡ªåŠ¨è¿”å›è¶…æ—¶ç»“æœ,ç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªæ–‡ä»¶
2. **æ€»æ˜¯ç”ŸæˆæŠ¥å‘Š**ï¼šå³ä½¿æœ‰æ–‡ä»¶è¶…æ—¶æˆ–ä¸­æ–­,å·²å®Œæˆçš„æ–‡ä»¶ä¹Ÿä¼šç”ŸæˆæŠ¥å‘Š
3. **æ˜ç¡®çš„è¶…æ—¶ä¿¡æ¯**ï¼šç”¨æˆ·å¯ä»¥çœ‹åˆ°å“ªäº›æ–‡ä»¶è¶…æ—¶,è¶…æ—¶æ—¶é—´æ˜¯å¤šå°‘
4. **æ”¯æŒè‡ªå®šä¹‰è¶…æ—¶**ï¼šå¯ä»¥æ ¹æ®é¡¹ç›®å¤§å°è°ƒæ•´ `file_timeout` å‚æ•°

**é…ç½®å»ºè®®**ï¼š
- å°æ–‡ä»¶(< 200 è¡Œ): 180 ç§’è¶³å¤Ÿ
- ä¸­ç­‰æ–‡ä»¶(200-1000 è¡Œ): 300-600 ç§’
- å¤§æ–‡ä»¶(1000+ è¡Œ): 600-900 ç§’
- ç‰¹å¤§æ–‡ä»¶(2000+ è¡Œ): å¯è€ƒè™‘æ‹†åˆ†æˆ–å¢åŠ åˆ° 1200 ç§’

**æäº¤ä¿¡æ¯**ï¼š
```
fix(checker): ä¿®å¤æ–‡ä»¶æ£€æŸ¥è¶…æ—¶å’ŒæŠ¥å‘Šæ— æ³•ç”Ÿæˆçš„é—®é¢˜

é—®é¢˜æè¿°:
1. å¤§æ–‡ä»¶(å¦‚ DictItemServiceImpl.java)åœ¨å¹¶å‘æ£€æŸ¥æ—¶å¡ä½ä¸åŠ¨
2. ç”±äºä¸€ä¸ªæ–‡ä»¶å¡ä½,å¯¼è‡´æ•´ä¸ªæ£€æŸ¥æ— æ³•å®Œæˆ,æŠ¥å‘Šæ— æ³•ç”Ÿæˆ

æ ¹æœ¬åŸå› :
1. ç¼ºå°‘æ–‡ä»¶çº§æ€»è¶…æ—¶ä¿æŠ¤(åªæœ‰ chunk çº§ 180 ç§’è¶…æ—¶)
2. æŠ¥å‘Šç”Ÿæˆä»£ç åœ¨æ£€æŸ¥å®Œæˆä¹‹å,è¢«é˜»å¡æ— æ³•æ‰§è¡Œ

è§£å†³æ–¹æ¡ˆ:
1. ä¸ºå•ä¸ªæ–‡ä»¶æ·»åŠ  600 ç§’æ€»è¶…æ—¶ä¿æŠ¤
2. å°† check_file() æ‹†åˆ†ä¸ºå¸¦è¶…æ—¶çš„å¤–å±‚å’Œå®ç°çš„å†…å±‚
3. å¹¶å‘æ£€æŸ¥ä¼ é€’è¶…æ—¶å‚æ•°ç»™æ¯ä¸ªæ–‡ä»¶
4. ä½¿ç”¨ try-finally ç¡®ä¿å³ä½¿éƒ¨åˆ†å¤±è´¥ä¹Ÿèƒ½ç”ŸæˆæŠ¥å‘Š
5. æ·»åŠ  timeout çŠ¶æ€çš„ç»Ÿè®¡å’Œæ˜¾ç¤º

ä¿®æ”¹æ–‡ä»¶:
- autocoder/checker/core.py (æ–‡ä»¶è¶…æ—¶æ§åˆ¶)
- autocoder/plugins/code_checker_plugin.py (æŠ¥å‘Šç”Ÿæˆä¿æŠ¤)

æµ‹è¯•: æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡, å‘åå…¼å®¹
```

---

**æœ€åæ›´æ–°**ï¼š2025-10-11
**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0.4
**ä½œè€…**ï¼šClaude AI
