# ä»£ç æ£€æŸ¥åŠŸèƒ½äºŒæ¬¡å¼€å‘æŒ‡å—

> é¢å‘å¼€å‘è€…çš„ä»£ç æ£€æŸ¥ç³»ç»Ÿæ¶æ„ã€æ‰©å±•å’Œå®šåˆ¶æŒ‡å—

## ğŸ“‹ ç›®å½•

- [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
- [æ ¸å¿ƒæ¨¡å—è¯¦è§£](#æ ¸å¿ƒæ¨¡å—è¯¦è§£)
- [æ’ä»¶ç³»ç»Ÿ](#æ’ä»¶ç³»ç»Ÿ)
- [æ·»åŠ æ–°è§„åˆ™](#æ·»åŠ æ–°è§„åˆ™)
- [æ‰©å±•æ–°åŠŸèƒ½](#æ‰©å±•æ–°åŠŸèƒ½)
- [API å‚è€ƒ](#api-å‚è€ƒ)
- [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)

---

## æ¶æ„æ¦‚è§ˆ

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Chat Auto Coder                      â”‚
â”‚                     (ä¸»åº”ç”¨)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â”‚ åŠ è½½æ’ä»¶
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CodeCheckerPlugin                          â”‚
â”‚            (å‘½ä»¤æ³¨å†Œå’Œè°ƒåº¦)                              â”‚
â”‚  - æ³¨å†Œ /check å‘½ä»¤                                      â”‚
â”‚  - è§£æå‚æ•°                                              â”‚
â”‚  - è°ƒç”¨æ£€æŸ¥å™¨                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼            â–¼            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  /check  â”‚  â”‚  /check  â”‚  â”‚  /check  â”‚
â”‚  /file   â”‚  â”‚ /folder  â”‚  â”‚ /resume  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚             â”‚              â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    CodeChecker        â”‚
        â”‚   (æ ¸å¿ƒæ£€æŸ¥é€»è¾‘)       â”‚
        â”‚  - åè°ƒå„æ¨¡å—          â”‚
        â”‚  - è°ƒç”¨ LLM           â”‚
        â”‚  - ç»“æœå¤„ç†            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼           â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Rules   â”‚ â”‚  File    â”‚ â”‚Progress  â”‚
â”‚  Loader  â”‚ â”‚Processor â”‚ â”‚ Tracker  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Report Generator    â”‚
        â”‚   (ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š)       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—å…³ç³»

| æ¨¡å— | æ–‡ä»¶ | èŒè´£ | ä¾èµ– |
|------|------|------|------|
| **æ’ä»¶** | `code_checker_plugin.py` | å‘½ä»¤æ³¨å†Œã€å‚æ•°è§£æ | CodeChecker |
| **æ ¸å¿ƒæ£€æŸ¥å™¨** | `core.py` | æ£€æŸ¥é€»è¾‘ã€LLM è°ƒç”¨ | æ‰€æœ‰æ¨¡å— |
| **è§„åˆ™åŠ è½½å™¨** | `rules_loader.py` | è§„åˆ™æ–‡ä»¶è§£æ | types.py |
| **æ–‡ä»¶å¤„ç†å™¨** | `file_processor.py` | æ–‡ä»¶æ‰«æã€åˆ†å— | types.py |
| **è¿›åº¦è·Ÿè¸ªå™¨** | `progress_tracker.py` | è¿›åº¦æŒä¹…åŒ– | types.py |
| **æŠ¥å‘Šç”Ÿæˆå™¨** | `report_generator.py` | æŠ¥å‘Šç”Ÿæˆ | types.py |
| **ç±»å‹å®šä¹‰** | `types.py` | æ•°æ®æ¨¡å‹ | pydantic |

### æ•°æ®æµ

```
1. ç”¨æˆ·è¾“å…¥å‘½ä»¤
   â†“
2. Plugin è§£æå‚æ•°
   â†“
3. CodeChecker.check_file() æˆ– check_files()
   â†“
4. RulesLoader åŠ è½½è§„åˆ™
   â†“
5. FileProcessor æ‰«æ/åˆ†å—æ–‡ä»¶
   â†“
6. CodeChecker è°ƒç”¨ LLM æ£€æŸ¥
   â†“
7. è§£æ LLM è¿”å›çš„ JSON
   â†“
8. ReportGenerator ç”ŸæˆæŠ¥å‘Š
   â†“
9. ProgressTracker ä¿å­˜è¿›åº¦
   â†“
10. è¿”å›ç»“æœç»™ç”¨æˆ·
```

---

## æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 1. types.py - ç±»å‹å®šä¹‰

**ä½ç½®**ï¼š`autocoder/checker/types.py`

**æ ¸å¿ƒç±»å‹**ï¼š

#### Severity - ä¸¥é‡ç¨‹åº¦æšä¸¾

```python
class Severity(str, Enum):
    ERROR = "error"      # é”™è¯¯ï¼šå¿…é¡»ä¿®å¤
    WARNING = "warning"  # è­¦å‘Šï¼šå»ºè®®ä¿®å¤
    INFO = "info"        # æç¤ºï¼šå¯é€‰ä¿®å¤
```

#### Rule - è§„åˆ™å®šä¹‰

```python
class Rule(BaseModel):
    id: str                    # è§„åˆ™IDï¼Œå¦‚ "backend_001"
    category: str              # è§„åˆ™ç±»åˆ«ï¼Œå¦‚ "ä»£ç ç»“æ„"
    title: str                 # è§„åˆ™æ ‡é¢˜
    description: str           # è§„åˆ™æè¿°
    severity: Severity         # ä¸¥é‡ç¨‹åº¦
    enabled: bool = True       # æ˜¯å¦å¯ç”¨
    examples: Optional[str]    # ç¤ºä¾‹ä»£ç 
```

#### Issue - æ£€æŸ¥é—®é¢˜

```python
class Issue(BaseModel):
    rule_id: str              # è¿åçš„è§„åˆ™ID
    severity: Severity        # ä¸¥é‡ç¨‹åº¦
    line_start: int           # é—®é¢˜èµ·å§‹è¡Œå·
    line_end: int             # é—®é¢˜ç»“æŸè¡Œå·
    description: str          # é—®é¢˜æè¿°
    suggestion: str           # ä¿®å¤å»ºè®®
    code_snippet: str         # é—®é¢˜ä»£ç ç‰‡æ®µ
```

#### FileCheckResult - æ–‡ä»¶æ£€æŸ¥ç»“æœ

```python
class FileCheckResult(BaseModel):
    file_path: str                # æ–‡ä»¶è·¯å¾„
    check_time: str              # æ£€æŸ¥æ—¶é—´
    issues: List[Issue]          # é—®é¢˜åˆ—è¡¨
    error_count: int             # é”™è¯¯æ•°é‡
    warning_count: int           # è­¦å‘Šæ•°é‡
    info_count: int              # æç¤ºæ•°é‡
    status: str                  # "success" | "failed" | "skipped"
    error_message: Optional[str] # é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
```

#### CheckState - æ£€æŸ¥çŠ¶æ€ï¼ˆç”¨äºæŒä¹…åŒ–ï¼‰

```python
class CheckState(BaseModel):
    check_id: str                  # æ£€æŸ¥ID
    start_time: str               # å¼€å§‹æ—¶é—´
    config: Dict[str, Any]        # é…ç½®å‚æ•°
    total_files: List[str]        # æ€»æ–‡ä»¶åˆ—è¡¨
    completed_files: List[str]    # å·²å®Œæˆæ–‡ä»¶
    remaining_files: List[str]    # å‰©ä½™æ–‡ä»¶
```

**æ‰©å±•å»ºè®®**ï¼š
- æ·»åŠ æ–°çš„ä¸¥é‡ç¨‹åº¦çº§åˆ«ï¼ˆå¦‚ CRITICALï¼‰
- æ·»åŠ è§„åˆ™åˆ†ç»„ï¼ˆRuleGroupï¼‰
- æ·»åŠ æ£€æŸ¥ç»Ÿè®¡ä¿¡æ¯ï¼ˆCheckStatisticsï¼‰

---

### 2. rules_loader.py - è§„åˆ™åŠ è½½å™¨

**ä½ç½®**ï¼š`autocoder/checker/rules_loader.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- åŠ è½½ Markdown æ ¼å¼çš„è§„åˆ™æ–‡ä»¶
- è§£æè§„åˆ™é…ç½®
- æ ¹æ®æ–‡ä»¶ç±»å‹é€‰æ‹©é€‚ç”¨è§„åˆ™
- è§„åˆ™ç¼“å­˜ä¼˜åŒ–

**å…³é”®æ–¹æ³•**ï¼š

#### load_rules() - åŠ è½½è§„åˆ™

```python
def load_rules(self, rule_type: str) -> List[Rule]:
    """
    åŠ è½½æŒ‡å®šç±»å‹çš„è§„åˆ™

    Args:
        rule_type: è§„åˆ™ç±»å‹ï¼ˆbackend/frontendï¼‰

    Returns:
        è§„åˆ™åˆ—è¡¨
    """
    # 1. æ£€æŸ¥ç¼“å­˜
    if rule_type in self._rule_cache:
        return self._rule_cache[rule_type]

    # 2. åŠ è½½è§„åˆ™æ–‡ä»¶
    rule_file = os.path.join(self.rules_dir, f"{rule_type}_rules.md")
    rules = self._parse_markdown_rules(rule_file)

    # 3. åº”ç”¨é…ç½®
    rules = self._apply_config(rules, rule_type)

    # 4. ç¼“å­˜ç»“æœ
    self._rule_cache[rule_type] = rules

    return rules
```

#### _parse_markdown_rules() - è§£æ Markdown è§„åˆ™

```python
def _parse_markdown_rules(self, file_path: str) -> List[Rule]:
    """
    è§£æ Markdown æ ¼å¼çš„è§„åˆ™æ–‡ä»¶

    è§„åˆ™æ ¼å¼ï¼š
    ### è§„åˆ™ID: backend_001
    **æ ‡é¢˜**: è§„åˆ™æ ‡é¢˜
    **ä¸¥é‡ç¨‹åº¦**: warning
    **æè¿°**: è§„åˆ™æè¿°
    """
    rules = []

    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # æŒ‰ "### è§„åˆ™ID:" åˆ†å‰²
    sections = re.split(r'### è§„åˆ™ID:\s*(\w+)', content)

    current_category = ""

    for i in range(1, len(sections), 2):
        rule_id = sections[i].strip()
        rule_content = sections[i+1]

        # æå–å­—æ®µ
        title = self._extract_field(rule_content, "æ ‡é¢˜")
        severity = self._extract_field(rule_content, "ä¸¥é‡ç¨‹åº¦")
        description = self._extract_field(rule_content, "æè¿°")

        # æå–ç¤ºä¾‹
        examples = self._extract_examples(rule_content)

        rules.append(Rule(
            id=rule_id,
            category=current_category,
            title=title,
            description=description,
            severity=Severity(severity),
            examples=examples
        ))

    return rules
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒ YAML/JSON æ ¼å¼çš„è§„åˆ™æ–‡ä»¶
- æ”¯æŒè§„åˆ™ç»§æ‰¿å’Œè¦†ç›–
- æ”¯æŒè§„åˆ™ä¼˜å…ˆçº§
- æ”¯æŒåŠ¨æ€è§„åˆ™ï¼ˆä»æ•°æ®åº“åŠ è½½ï¼‰

---

### 3. file_processor.py - æ–‡ä»¶å¤„ç†å™¨

**ä½ç½®**ï¼š`autocoder/checker/file_processor.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- æ–‡ä»¶æ‰«æå’Œè¿‡æ»¤
- å¤§æ–‡ä»¶åˆ†å—
- æ–‡ä»¶ç±»å‹æ£€æµ‹

**å…³é”®æ–¹æ³•**ï¼š

#### scan_files() - æ‰«ææ–‡ä»¶

```python
def scan_files(self, path: str, filters: FileFilters) -> List[str]:
    """
    æ‰«æç›®å½•ï¼Œè¿”å›ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶åˆ—è¡¨

    Args:
        path: æ‰«æè·¯å¾„
        filters: æ–‡ä»¶è¿‡æ»¤å™¨ï¼ˆæ‰©å±•åã€å¿½ç•¥æ¨¡å¼ï¼‰

    Returns:
        æ–‡ä»¶è·¯å¾„åˆ—è¡¨
    """
    files = []

    for root, dirs, filenames in os.walk(path):
        # è¿‡æ»¤å¿½ç•¥çš„ç›®å½•
        dirs[:] = [d for d in dirs if not self._should_ignore(d, filters.ignored)]

        for filename in filenames:
            file_path = os.path.join(root, filename)

            # æ£€æŸ¥æ‰©å±•å
            if filters.extensions:
                if not any(file_path.endswith(ext) for ext in filters.extensions):
                    continue

            # æ£€æŸ¥å¿½ç•¥æ¨¡å¼
            if self._should_ignore(file_path, filters.ignored):
                continue

            # æ£€æŸ¥æ˜¯å¦å¯æ£€æŸ¥
            if self.is_checkable(file_path):
                files.append(file_path)

    return files
```

#### chunk_file() - æ–‡ä»¶åˆ†å—

```python
def chunk_file(self, file_path: str) -> List[CodeChunk]:
    """
    å°†å¤§æ–‡ä»¶åˆ†å—ï¼Œç¡®ä¿æ¯å—ä¸è¶…è¿‡ token é™åˆ¶

    ç­–ç•¥ï¼š
    1. ä¸ºæ¯è¡Œæ·»åŠ è¡Œå·
    2. è®¡ç®—æ€» token æ•°
    3. å¦‚æœè¶…è¿‡é™åˆ¶ï¼ŒæŒ‰ token åˆ†å—
    4. å—ä¹‹é—´æœ‰é‡å ï¼Œé¿å…è¾¹ç•Œé—®é¢˜
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # æ·»åŠ è¡Œå·
    numbered_lines = [f"{i+1} {line}" for i, line in enumerate(lines)]

    # è®¡ç®— tokens
    total_tokens = count_tokens('\n'.join(numbered_lines))

    # ä¸éœ€è¦åˆ†å—
    if total_tokens <= self.chunk_size:
        return [CodeChunk(
            content='\n'.join(numbered_lines),
            start_line=1,
            end_line=len(lines),
            chunk_index=0,
            total_chunks=1
        )]

    # éœ€è¦åˆ†å—
    chunks = []
    current_line = 0
    chunk_index = 0

    while current_line < len(numbered_lines):
        # è®¡ç®—å½“å‰ chunk çš„ç»“æŸè¡Œ
        end_line = self._calculate_chunk_end(
            numbered_lines,
            current_line,
            self.chunk_size
        )

        # åˆ›å»º chunk
        chunk_content = '\n'.join(numbered_lines[current_line:end_line])
        chunks.append(CodeChunk(
            content=chunk_content,
            start_line=current_line + 1,
            end_line=end_line,
            chunk_index=chunk_index,
            total_chunks=0  # ç¨åæ›´æ–°
        ))

        # ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª chunkï¼ˆè€ƒè™‘é‡å ï¼‰
        current_line = end_line - self.overlap
        chunk_index += 1

    # æ›´æ–°æ€» chunk æ•°
    for chunk in chunks:
        chunk.total_chunks = len(chunks)

    return chunks
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒæ™ºèƒ½åˆ†å—ï¼ˆæŒ‰å‡½æ•°/ç±»è¾¹ç•Œï¼‰
- æ”¯æŒå¢é‡æ£€æŸ¥ï¼ˆåªæ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶ï¼‰
- æ”¯æŒ Git diff é›†æˆ
- æ”¯æŒæ–‡ä»¶å†…å®¹ç¼“å­˜

---

### 4. core.py - æ ¸å¿ƒæ£€æŸ¥å™¨

**ä½ç½®**ï¼š`autocoder/checker/core.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- åè°ƒå„æ¨¡å—å®Œæˆæ£€æŸ¥
- è°ƒç”¨ LLM è¿›è¡Œä»£ç æ£€æŸ¥
- å¤„ç†æ£€æŸ¥ç»“æœ
- ç®¡ç†å¹¶å‘æ‰§è¡Œ

**å…³é”®æ–¹æ³•**ï¼š

#### check_file() - å•æ–‡ä»¶æ£€æŸ¥

```python
def check_file(self, file_path: str) -> FileCheckResult:
    """
    æ£€æŸ¥å•ä¸ªæ–‡ä»¶

    æµç¨‹ï¼š
    1. åŠ è½½é€‚ç”¨è§„åˆ™
    2. è¯»å–æ–‡ä»¶å¹¶åˆ†å—
    3. æ£€æŸ¥æ¯ä¸ª chunk
    4. åˆå¹¶ç»“æœ
    5. è¿”å›æ£€æŸ¥ç»“æœ
    """
    try:
        start_time = datetime.now()

        # 1. è·å–é€‚ç”¨è§„åˆ™
        rules = self.rules_loader.get_applicable_rules(file_path)
        if not rules:
            return FileCheckResult(
                file_path=file_path,
                check_time=start_time.isoformat(),
                issues=[],
                status="skipped"
            )

        # 2. åˆ†å—å¤„ç†
        chunks = self.file_processor.chunk_file(file_path)
        logger.info(f"æ–‡ä»¶ {file_path} è¢«åˆ†ä¸º {len(chunks)} ä¸ª chunks")

        # 3. æ£€æŸ¥æ¯ä¸ª chunk
        all_issues = []
        for chunk in chunks:
            issues = self.check_code_chunk(chunk.content, rules)
            all_issues.extend(issues)

        # 4. åˆå¹¶é‡å¤é—®é¢˜
        merged_issues = self._merge_duplicate_issues(all_issues)

        # 5. ç»Ÿè®¡
        error_count = sum(1 for i in merged_issues if i.severity == Severity.ERROR)
        warning_count = sum(1 for i in merged_issues if i.severity == Severity.WARNING)
        info_count = sum(1 for i in merged_issues if i.severity == Severity.INFO)

        return FileCheckResult(
            file_path=file_path,
            check_time=datetime.now().isoformat(),
            issues=merged_issues,
            error_count=error_count,
            warning_count=warning_count,
            info_count=info_count,
            status="success"
        )

    except Exception as e:
        logger.error(f"æ£€æŸ¥æ–‡ä»¶ {file_path} å¤±è´¥: {e}")
        return FileCheckResult(
            file_path=file_path,
            check_time=datetime.now().isoformat(),
            issues=[],
            error_count=0,
            warning_count=0,
            info_count=0,
            status="failed",
            error_message=str(e)
        )
```

#### check_code_chunk() - æ£€æŸ¥ä»£ç å—

```python
@byzerllm.prompt()
def check_code_prompt(self, code_with_lines: str, rules: str) -> str:
    """
    ä½ æ˜¯ä¸€ä¸ªä»£ç å®¡æŸ¥ä¸“å®¶ã€‚è¯·æ ¹æ®æä¾›çš„è§„åˆ™æ£€æŸ¥ä»£ç ï¼Œæ‰¾å‡ºä¸ç¬¦åˆè§„èŒƒçš„åœ°æ–¹ã€‚

    ## æ£€æŸ¥è§„åˆ™

    {{ rules }}

    ## å¾…æ£€æŸ¥ä»£ç ï¼ˆå¸¦è¡Œå·ï¼‰

    ```
    {{ code_with_lines }}
    ```

    ## è¾“å‡ºè¦æ±‚

    è¯·ä»”ç»†æ£€æŸ¥ä»£ç ï¼Œå¯¹äºæ¯ä¸ªå‘ç°çš„é—®é¢˜ï¼š
    1. å‡†ç¡®å®šä½é—®é¢˜çš„èµ·å§‹å’Œç»“æŸè¡Œå·
    2. å¼•ç”¨è¿åçš„è§„åˆ™ID
    3. æè¿°é—®é¢˜
    4. æä¾›ä¿®å¤å»ºè®®

    ä»¥ JSON æ•°ç»„æ ¼å¼è¾“å‡ºï¼Œæ¯ä¸ªé—®é¢˜åŒ…å«ï¼š
    - rule_id: è¿åçš„è§„åˆ™ID
    - severity: ä¸¥é‡ç¨‹åº¦ (error/warning/info)
    - line_start: é—®é¢˜èµ·å§‹è¡Œå·ï¼ˆæ•´æ•°ï¼‰
    - line_end: é—®é¢˜ç»“æŸè¡Œå·ï¼ˆæ•´æ•°ï¼‰
    - description: é—®é¢˜æè¿°
    - suggestion: ä¿®å¤å»ºè®®

    å¦‚æœæ²¡æœ‰å‘ç°é—®é¢˜ï¼Œè¿”å›ç©ºæ•°ç»„ []

    ç¤ºä¾‹è¾“å‡ºï¼š
    ```json
    [
        {
            "rule_id": "backend_006",
            "severity": "warning",
            "line_start": 15,
            "line_end": 32,
            "description": "å‘ç°å¤æ‚çš„ if-else åµŒå¥—",
            "suggestion": "å»ºè®®å°†å†…å±‚é€»è¾‘æŠ½å–ä¸ºç‹¬ç«‹æ–¹æ³•"
        }
    ]
    ```
    """

def check_code_chunk(self, code: str, rules: List[Rule]) -> List[Issue]:
    """è°ƒç”¨ LLM æ£€æŸ¥ä»£ç å—"""
    # æ ¼å¼åŒ–è§„åˆ™
    rules_text = self._format_rules(rules)

    # è°ƒç”¨ LLM
    response = self.llm.chat_oai(
        conversations=[{
            "role": "user",
            "content": self.check_code_prompt(code, rules_text)
        }]
    )[0].output

    # è§£æ JSON
    issues = self._parse_llm_response(response)

    return issues
```

#### check_files_concurrent() - å¹¶å‘æ£€æŸ¥

```python
def check_files_concurrent(
    self, files: List[str], max_workers: int = 5
) -> Generator[FileCheckResult, None, None]:
    """
    å¹¶å‘æ£€æŸ¥å¤šä¸ªæ–‡ä»¶

    ä½¿ç”¨ ThreadPoolExecutor å®ç°å¹¶å‘æ£€æŸ¥ï¼Œæé«˜å¤§å‹é¡¹ç›®çš„æ£€æŸ¥é€Ÿåº¦ã€‚
    ä½¿ç”¨ç”Ÿæˆå™¨æ¨¡å¼æŒ‰å®Œæˆé¡ºåºå®æ—¶è¿”å›ç»“æœï¼Œé€‚åˆä¸è¿›åº¦æ¡é…åˆä½¿ç”¨ã€‚

    Args:
        files: æ–‡ä»¶åˆ—è¡¨
        max_workers: æœ€å¤§å¹¶å‘æ•°

    Yields:
        FileCheckResult: æŒ‰å®Œæˆé¡ºåºè¿”å›æ£€æŸ¥ç»“æœ
    """
    logger.info(f"å¼€å§‹å¹¶å‘æ£€æŸ¥ {len(files)} ä¸ªæ–‡ä»¶ (workers={max_workers})")

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡
        future_to_file = {
            executor.submit(self.check_file, file_path): file_path
            for file_path in files
        }

        # æŒ‰å®Œæˆé¡ºåºè¿”å›ç»“æœ
        for future in as_completed(future_to_file):
            file_path = future_to_file[future]
            try:
                result = future.result()
                yield result
            except Exception as exc:
                logger.error(f"æ–‡ä»¶ {file_path} æ£€æŸ¥å¤±è´¥: {exc}")
                yield FileCheckResult(
                    file_path=file_path,
                    check_time=datetime.now().isoformat(),
                    issues=[],
                    error_count=0,
                    warning_count=0,
                    info_count=0,
                    status="failed",
                    error_message=str(exc)
                )
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒè‡ªå®šä¹‰ Prompt æ¨¡æ¿
- æ”¯æŒå¤šæ¨¡å‹å¯¹æ¯”æ£€æŸ¥
- æ”¯æŒå¢é‡æ£€æŸ¥ä¼˜åŒ–
- æ”¯æŒæ£€æŸ¥ç»“æœç¼“å­˜

---

### 5. progress_tracker.py - è¿›åº¦è·Ÿè¸ªå™¨

**ä½ç½®**ï¼š`autocoder/checker/progress_tracker.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- è·Ÿè¸ªæ£€æŸ¥è¿›åº¦
- æŒä¹…åŒ–æ£€æŸ¥çŠ¶æ€
- æ”¯æŒä¸­æ–­æ¢å¤

**å…³é”®æ–¹æ³•**ï¼š

#### start_check() - å¼€å§‹æ£€æŸ¥

```python
def start_check(self, files: List[str], config: Dict[str, Any]) -> str:
    """
    å¼€å§‹æ–°çš„æ£€æŸ¥ï¼Œè¿”å› check_id

    Args:
        files: æ–‡ä»¶åˆ—è¡¨
        config: æ£€æŸ¥é…ç½®

    Returns:
        check_id: æ ¼å¼ä¸º {project}_{timestamp}
    """
    # ç”Ÿæˆ check_id
    project_name = os.path.basename(os.getcwd())
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    check_id = f"{project_name}_{timestamp}"

    # åˆ›å»ºæ£€æŸ¥çŠ¶æ€
    state = CheckState(
        check_id=check_id,
        start_time=datetime.now().isoformat(),
        config=config,
        total_files=files,
        completed_files=[],
        remaining_files=files
    )

    # ä¿å­˜çŠ¶æ€
    self.save_state(check_id, state)

    return check_id
```

#### mark_completed() - æ ‡è®°å®Œæˆ

```python
def mark_completed(self, check_id: str, file_path: str) -> None:
    """æ ‡è®°æ–‡ä»¶å·²å®Œæˆæ£€æŸ¥"""
    # åŠ è½½çŠ¶æ€
    state = self.load_state(check_id)

    # æ›´æ–°çŠ¶æ€
    if file_path in state.remaining_files:
        state.remaining_files.remove(file_path)

    if file_path not in state.completed_files:
        state.completed_files.append(file_path)

    # ä¿å­˜çŠ¶æ€
    self.save_state(check_id, state)
```

#### resume_check() - æ¢å¤æ£€æŸ¥

```python
def get_remaining_files(self, check_id: str) -> List[str]:
    """è·å–å¾…æ£€æŸ¥çš„æ–‡ä»¶åˆ—è¡¨"""
    state = self.load_state(check_id)
    return state.remaining_files if state else []
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒæ£€æŸ¥å†å²ç®¡ç†
- æ”¯æŒæ£€æŸ¥ç»Ÿè®¡åˆ†æ
- æ”¯æŒå¤šç”¨æˆ·æ£€æŸ¥éš”ç¦»
- æ”¯æŒåˆ†å¸ƒå¼æ£€æŸ¥åè°ƒ

---

### 6. report_generator.py - æŠ¥å‘Šç”Ÿæˆå™¨

**ä½ç½®**ï¼š`autocoder/checker/report_generator.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- ç”Ÿæˆ JSON æ ¼å¼æŠ¥å‘Š
- ç”Ÿæˆ Markdown æ ¼å¼æŠ¥å‘Š
- ç”Ÿæˆæ±‡æ€»ç»Ÿè®¡

**å…³é”®æ–¹æ³•**ï¼š

#### generate_file_report() - ç”Ÿæˆæ–‡ä»¶æŠ¥å‘Š

```python
def generate_file_report(self, result: FileCheckResult, report_dir: str) -> None:
    """ç”Ÿæˆå•ä¸ªæ–‡ä»¶çš„æ£€æŸ¥æŠ¥å‘Š"""
    # åˆ›å»ºæŠ¥å‘Šç›®å½•
    files_dir = os.path.join(report_dir, "files")
    os.makedirs(files_dir, exist_ok=True)

    # ç”Ÿæˆæ–‡ä»¶åï¼ˆæ›¿æ¢è·¯å¾„åˆ†éš”ç¬¦ï¼‰
    safe_filename = result.file_path.replace("/", "_").replace("\\", "_")

    # ç”Ÿæˆ JSON æŠ¥å‘Š
    json_path = os.path.join(files_dir, f"{safe_filename}.json")
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(result.dict(), f, indent=2, ensure_ascii=False)

    # ç”Ÿæˆ Markdown æŠ¥å‘Š
    md_path = os.path.join(files_dir, f"{safe_filename}.md")
    md_content = self._generate_file_markdown(result)
    with open(md_path, 'w', encoding='utf-8') as f:
        f.write(md_content)
```

#### generate_summary_report() - ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š

```python
def generate_summary_report(
    self, results: List[FileCheckResult], report_dir: str
) -> None:
    """ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š"""
    # ç»Ÿè®¡ä¿¡æ¯
    total_files = len(results)
    total_issues = sum(len(r.issues) for r in results)
    total_errors = sum(r.error_count for r in results)
    total_warnings = sum(r.warning_count for r in results)
    total_infos = sum(r.info_count for r in results)

    # é—®é¢˜æœ€å¤šçš„æ–‡ä»¶
    top_files = sorted(
        results,
        key=lambda r: len(r.issues),
        reverse=True
    )[:10]

    # æŒ‰è§„åˆ™åˆ†ç±»
    rule_counts = {}
    for result in results:
        for issue in result.issues:
            rule_counts[issue.rule_id] = rule_counts.get(issue.rule_id, 0) + 1

    # ç”Ÿæˆæ±‡æ€»æ•°æ®
    summary = {
        "check_id": os.path.basename(report_dir),
        "total_files": total_files,
        "total_issues": total_issues,
        "error_count": total_errors,
        "warning_count": total_warnings,
        "info_count": total_infos,
        "top_files": [
            {"file": f.file_path, "issues": len(f.issues)}
            for f in top_files
        ],
        "rule_distribution": rule_counts
    }

    # ä¿å­˜ JSON
    with open(os.path.join(report_dir, "summary.json"), 'w') as f:
        json.dump(summary, f, indent=2, ensure_ascii=False)

    # ä¿å­˜ Markdown
    md_content = self._generate_summary_markdown(summary, results)
    with open(os.path.join(report_dir, "summary.md"), 'w') as f:
        f.write(md_content)
```

**æ‰©å±•å»ºè®®**ï¼š
- æ”¯æŒ HTML æŠ¥å‘Š
- æ”¯æŒ PDF å¯¼å‡º
- æ”¯æŒè¶‹åŠ¿åˆ†æï¼ˆå¤šæ¬¡æ£€æŸ¥å¯¹æ¯”ï¼‰
- æ”¯æŒè‡ªå®šä¹‰æŠ¥å‘Šæ¨¡æ¿

---

## æ’ä»¶ç³»ç»Ÿ

### CodeCheckerPlugin

**ä½ç½®**ï¼š`autocoder/plugins/code_checker_plugin.py`

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- æ³¨å†Œ `/check` å‘½ä»¤åŠå­å‘½ä»¤
- æä¾›å‘½ä»¤è¡¥å…¨
- å‚æ•°è§£æå’ŒéªŒè¯
- è°ƒç”¨æ ¸å¿ƒæ£€æŸ¥é€»è¾‘

**æ’ä»¶ç»“æ„**ï¼š

```python
class CodeCheckerPlugin(Plugin):
    name = "code_checker"
    description = "ä»£ç è§„èŒƒæ£€æŸ¥æ’ä»¶"
    version = "1.0.0"

    def initialize(self) -> bool:
        """åˆå§‹åŒ–æ’ä»¶"""
        # åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
        self.checker = CodeChecker(self.llm, self.args)
        self.report_generator = ReportGenerator()
        self.progress_tracker = ProgressTracker()

        return True

    def get_commands(self):
        """æ³¨å†Œå‘½ä»¤"""
        return {
            "check": (self.handle_check, "ä»£ç æ£€æŸ¥å‘½ä»¤"),
        }

    def get_completions(self):
        """æä¾›å‘½ä»¤è¡¥å…¨"""
        return {
            "/check": ["/file", "/folder", "/resume", "/report"],
            "/check /folder": ["/path", "/ext", "/ignore", "/workers"],
        }
```

**å‘½ä»¤å¤„ç†**ï¼š

```python
def handle_check(self, args: str):
    """å¤„ç† /check å‘½ä»¤"""
    parts = args.strip().split(maxsplit=1)

    if not parts:
        print(self._show_help())
        return

    subcommand = parts[0]

    if subcommand == "/file":
        self._check_file(parts[1] if len(parts) > 1 else "")
    elif subcommand == "/folder":
        self._check_folder(parts[1] if len(parts) > 1 else "")
    elif subcommand == "/resume":
        self._resume_check(parts[1] if len(parts) > 1 else "")
    else:
        print(f"æœªçŸ¥å­å‘½ä»¤: {subcommand}")
        print(self._show_help())
```

**æ‰©å±•æ’ä»¶**ï¼š

1. **åˆ›å»ºæ–°æ’ä»¶**ï¼š
   ```python
   class MyCheckerPlugin(CodeCheckerPlugin):
       name = "my_checker"

       def initialize(self):
           super().initialize()
           # è‡ªå®šä¹‰åˆå§‹åŒ–
           return True

       def get_commands(self):
           commands = super().get_commands()
           # æ·»åŠ æ–°å‘½ä»¤
           commands["mycheck"] = (self.handle_mycheck, "æˆ‘çš„æ£€æŸ¥")
           return commands
   ```

2. **æ³¨å†Œæ’ä»¶**ï¼š
   åœ¨ `autocoder/plugins/__init__.py` ä¸­æ³¨å†Œ

---

## æ·»åŠ æ–°è§„åˆ™

### è§„åˆ™æ–‡ä»¶æ ¼å¼

è§„åˆ™æ–‡ä»¶ä½¿ç”¨ Markdown æ ¼å¼ï¼Œä¾¿äºé˜…è¯»å’Œç»´æŠ¤ã€‚

**æ–‡ä»¶ä½ç½®**ï¼š
- åç«¯è§„åˆ™ï¼š`rules/backend_rules.md`
- å‰ç«¯è§„åˆ™ï¼š`rules/frontend_rules.md`

**è§„åˆ™æ ¼å¼**ï¼š

```markdown
## è§„åˆ™ç±»åˆ«åç§°

### è§„åˆ™ID: backend_xxx
**æ ‡é¢˜**: è§„åˆ™æ ‡é¢˜
**ä¸¥é‡ç¨‹åº¦**: warning
**æè¿°**: è§„åˆ™çš„è¯¦ç»†æè¿°ï¼Œè¯´æ˜ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªè§„åˆ™

**é”™è¯¯ç¤ºä¾‹**:
```python
# é”™è¯¯çš„ä»£ç ç¤ºä¾‹
def bad_example():
    # è¿åè§„åˆ™çš„ä»£ç 
    pass
```

**æ­£ç¡®ç¤ºä¾‹**:
```python
# æ­£ç¡®çš„ä»£ç ç¤ºä¾‹
def good_example():
    # ç¬¦åˆè§„åˆ™çš„ä»£ç 
    pass
```
```

### æ·»åŠ æ–°è§„åˆ™æ­¥éª¤

1. **ç¼–è¾‘è§„åˆ™æ–‡ä»¶**

   ```bash
   vim rules/backend_rules.md
   ```

2. **æ·»åŠ è§„åˆ™**

   ```markdown
   ## æ€§èƒ½ä¼˜åŒ–

   ### è§„åˆ™ID: backend_100
   **æ ‡é¢˜**: é¿å…åœ¨å¾ªç¯ä¸­è¿›è¡Œæ•°æ®åº“æŸ¥è¯¢
   **ä¸¥é‡ç¨‹åº¦**: error
   **æè¿°**: åœ¨å¾ªç¯ä¸­è¿›è¡Œæ•°æ®åº“æŸ¥è¯¢ä¼šå¯¼è‡´ N+1 é—®é¢˜ï¼Œä¸¥é‡å½±å“æ€§èƒ½ã€‚åº”è¯¥ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢æˆ– JOIN ä¼˜åŒ–ã€‚

   **é”™è¯¯ç¤ºä¾‹**:
   ```python
   def get_user_posts(user_ids):
       posts = []
       for user_id in user_ids:
           # æ¯æ¬¡å¾ªç¯éƒ½æŸ¥è¯¢æ•°æ®åº“
           user_posts = db.query(Post).filter(Post.user_id == user_id).all()
           posts.extend(user_posts)
       return posts
   ```

   **æ­£ç¡®ç¤ºä¾‹**:
   ```python
   def get_user_posts(user_ids):
       # æ‰¹é‡æŸ¥è¯¢
       posts = db.query(Post).filter(Post.user_id.in_(user_ids)).all()
       return posts
   ```
   ```

3. **æ›´æ–°è§„åˆ™é…ç½®**ï¼ˆå¯é€‰ï¼‰

   å¦‚æœéœ€è¦ç‰¹æ®Šé…ç½®ï¼Œç¼–è¾‘ `rules/rules_config.json`ï¼š

   ```json
   {
     "rule_sets": {
       "backend": {
         "enabled": true,
         "disabled_rules": []  // å¦‚éœ€ç¦ç”¨æŸè§„åˆ™ï¼Œæ·»åŠ åˆ°è¿™é‡Œ
       }
     }
   }
   ```

4. **æµ‹è¯•è§„åˆ™**

   ```bash
   # å¯åŠ¨ chat_auto_coder
   python -m autocoder.chat_auto_coder

   # æµ‹è¯•æ–°è§„åˆ™
   /check /file test_file.py
   ```

5. **éªŒè¯ç»“æœ**

   æ£€æŸ¥ç”Ÿæˆçš„æŠ¥å‘Šï¼Œç¡®è®¤æ–°è§„åˆ™æ­£ç¡®ç”Ÿæ•ˆ

### è§„åˆ™æœ€ä½³å®è·µ

1. **è§„åˆ™IDè§„èŒƒ**
   - åç«¯ï¼š`backend_001` - `backend_999`
   - å‰ç«¯ï¼š`frontend_001` - `frontend_999`
   - æŒ‰ç±»åˆ«åˆ†æ®µï¼ˆå¦‚ 001-099 ä»£ç ç»“æ„ï¼Œ100-199 æ€§èƒ½ä¼˜åŒ–ï¼‰

2. **ä¸¥é‡ç¨‹åº¦é€‰æ‹©**
   - `error`ï¼šå¿…é¡»ä¿®å¤çš„é—®é¢˜ï¼ˆå®‰å…¨ã€è‡´å‘½bugï¼‰
   - `warning`ï¼šå»ºè®®ä¿®å¤çš„é—®é¢˜ï¼ˆæ€§èƒ½ã€è§„èŒƒï¼‰
   - `info`ï¼šæç¤ºæ€§ä¿¡æ¯ï¼ˆä¼˜åŒ–å»ºè®®ï¼‰

3. **æè¿°ç¼–å†™**
   - è¯´æ˜"ä¸ºä»€ä¹ˆ"è€Œä¸åªæ˜¯"æ˜¯ä»€ä¹ˆ"
   - æä¾›å…·ä½“çš„ä¿®å¤å»ºè®®
   - åŒ…å«æ­£åç¤ºä¾‹

4. **ç¤ºä¾‹ä»£ç **
   - ä½¿ç”¨å®é™…åœºæ™¯çš„ä»£ç 
   - ç¤ºä¾‹ç®€æ´æ˜äº†
   - çªå‡ºå…³é”®é—®é¢˜

---

## æ‰©å±•æ–°åŠŸèƒ½

### 1. æ·»åŠ æ–°çš„æ£€æŸ¥ç±»å‹

å‡è®¾è¦æ·»åŠ  SQL æ£€æŸ¥ï¼š

**æ­¥éª¤ 1ï¼šåˆ›å»ºè§„åˆ™æ–‡ä»¶**

```bash
# åˆ›å»º SQL è§„åˆ™æ–‡ä»¶
vim rules/sql_rules.md
```

**æ­¥éª¤ 2ï¼šç¼–å†™è§„åˆ™**

```markdown
## SQL è§„èŒƒ

### è§„åˆ™ID: sql_001
**æ ‡é¢˜**: é¿å…ä½¿ç”¨ SELECT *
**ä¸¥é‡ç¨‹åº¦**: warning
**æè¿°**: SELECT * ä¼šæŸ¥è¯¢æ‰€æœ‰å­—æ®µï¼Œå½±å“æ€§èƒ½ï¼Œä¸”åœ¨è¡¨ç»“æ„å˜æ›´æ—¶å¯èƒ½å¯¼è‡´é—®é¢˜

**é”™è¯¯ç¤ºä¾‹**:
```sql
SELECT * FROM users WHERE id = 1;
```

**æ­£ç¡®ç¤ºä¾‹**:
```sql
SELECT id, name, email FROM users WHERE id = 1;
```
```

**æ­¥éª¤ 3ï¼šæ›´æ–°é…ç½®**

ç¼–è¾‘ `rules/rules_config.json`ï¼š

```json
{
  "rule_sets": {
    "backend": { ... },
    "frontend": { ... },
    "sql": {
      "enabled": true,
      "file_patterns": ["**/*.sql"],
      "severity_threshold": "warning",
      "disabled_rules": []
    }
  }
}
```

**æ­¥éª¤ 4ï¼šæ›´æ–° RulesLoader**

åœ¨ `autocoder/checker/rules_loader.py` ä¸­æ·»åŠ ï¼š

```python
def get_applicable_rules(self, file_path: str) -> List[Rule]:
    """æ ¹æ®æ–‡ä»¶è·¯å¾„è·å–é€‚ç”¨çš„è§„åˆ™"""
    ext = os.path.splitext(file_path)[1].lower()

    # ç°æœ‰æ˜ å°„
    if ext == ".py":
        return self.load_rules("backend")
    elif ext in [".js", ".jsx", ".ts", ".tsx", ".vue"]:
        return self.load_rules("frontend")
    elif ext == ".sql":  # æ–°å¢
        return self.load_rules("sql")

    return []
```

### 2. æ·»åŠ è‡ªå®šä¹‰æŠ¥å‘Šæ ¼å¼

å‡è®¾è¦æ·»åŠ  HTML æŠ¥å‘Šï¼š

**æ­¥éª¤ 1ï¼šåˆ›å»ºæŠ¥å‘Šç”Ÿæˆæ–¹æ³•**

åœ¨ `autocoder/checker/report_generator.py` ä¸­æ·»åŠ ï¼š

```python
def generate_html_report(
    self, results: List[FileCheckResult], report_dir: str
) -> None:
    """ç”Ÿæˆ HTML æ ¼å¼æŠ¥å‘Š"""
    # HTML æ¨¡æ¿
    html_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>ä»£ç æ£€æŸ¥æŠ¥å‘Š</title>
        <style>
            /* CSS æ ·å¼ */
        </style>
    </head>
    <body>
        <h1>ä»£ç æ£€æŸ¥æŠ¥å‘Š</h1>
        {content}
    </body>
    </html>
    """

    # ç”Ÿæˆå†…å®¹
    content = self._generate_html_content(results)

    # ä¿å­˜æ–‡ä»¶
    html_path = os.path.join(report_dir, "report.html")
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_template.format(content=content))
```

**æ­¥éª¤ 2ï¼šè°ƒç”¨ç”Ÿæˆæ–¹æ³•**

åœ¨æ’ä»¶ä¸­è°ƒç”¨ï¼š

```python
def _check_folder(self, args: str):
    # ... æ£€æŸ¥é€»è¾‘ ...

    # ç”ŸæˆæŠ¥å‘Š
    self.report_generator.generate_summary_report(results, report_dir)
    self.report_generator.generate_html_report(results, report_dir)  # æ–°å¢
```

### 3. é›†æˆå¤–éƒ¨æ£€æŸ¥å·¥å…·

å‡è®¾è¦é›†æˆ Pylintï¼š

**æ­¥éª¤ 1ï¼šåˆ›å»ºå·¥å…·åŒ…è£…å™¨**

```python
# autocoder/checker/tools/pylint_wrapper.py

import subprocess
import json
from typing import List
from ..types import Issue, Severity

class PylintWrapper:
    def check(self, file_path: str) -> List[Issue]:
        """ä½¿ç”¨ Pylint æ£€æŸ¥æ–‡ä»¶"""
        # è¿è¡Œ Pylint
        result = subprocess.run(
            ["pylint", "--output-format=json", file_path],
            capture_output=True,
            text=True
        )

        # è§£æç»“æœ
        pylint_issues = json.loads(result.stdout)

        # è½¬æ¢ä¸º Issue å¯¹è±¡
        issues = []
        for item in pylint_issues:
            issues.append(Issue(
                rule_id=f"pylint_{item['message-id']}",
                severity=self._map_severity(item['type']),
                line_start=item['line'],
                line_end=item['line'],
                description=item['message'],
                suggestion=item.get('hint', ''),
                code_snippet=''
            ))

        return issues

    def _map_severity(self, pylint_type: str) -> Severity:
        """æ˜ å°„ Pylint ä¸¥é‡ç¨‹åº¦"""
        mapping = {
            'error': Severity.ERROR,
            'warning': Severity.WARNING,
            'convention': Severity.INFO,
            'refactor': Severity.INFO,
        }
        return mapping.get(pylint_type, Severity.INFO)
```

**æ­¥éª¤ 2ï¼šé›†æˆåˆ°æ£€æŸ¥æµç¨‹**

åœ¨ `core.py` ä¸­ï¼š

```python
def check_file(self, file_path: str) -> FileCheckResult:
    """æ£€æŸ¥å•ä¸ªæ–‡ä»¶"""
    # LLM æ£€æŸ¥
    llm_issues = self._check_with_llm(file_path)

    # Pylint æ£€æŸ¥ï¼ˆå¯é€‰ï¼‰
    if self.enable_pylint and file_path.endswith('.py'):
        pylint = PylintWrapper()
        pylint_issues = pylint.check(file_path)
        llm_issues.extend(pylint_issues)

    # åˆå¹¶ç»“æœ
    merged_issues = self._merge_duplicate_issues(llm_issues)

    # ... è¿”å›ç»“æœ
```

---

## API å‚è€ƒ

### CodeChecker

```python
class CodeChecker:
    def __init__(self, llm: byzerllm.ByzerLLM, args: AutoCoderArgs)

    def check_file(self, file_path: str) -> FileCheckResult
        """æ£€æŸ¥å•ä¸ªæ–‡ä»¶"""

    def check_files_concurrent(
        self, files: List[str], max_workers: int = 5
    ) -> Generator[FileCheckResult, None, None]
        """å¹¶å‘æ£€æŸ¥å¤šä¸ªæ–‡ä»¶"""

    def check_code_chunk(
        self, code: str, rules: List[Rule]
    ) -> List[Issue]
        """æ£€æŸ¥ä»£ç å—"""
```

### RulesLoader

```python
class RulesLoader:
    def __init__(self, rules_dir: str = "rules")

    def load_rules(self, rule_type: str) -> List[Rule]
        """åŠ è½½æŒ‡å®šç±»å‹çš„è§„åˆ™"""

    def get_applicable_rules(self, file_path: str) -> List[Rule]
        """æ ¹æ®æ–‡ä»¶è·¯å¾„è·å–é€‚ç”¨çš„è§„åˆ™"""

    def reload_rules(self) -> None
        """é‡æ–°åŠ è½½æ‰€æœ‰è§„åˆ™"""
```

### FileProcessor

```python
class FileProcessor:
    def __init__(self, chunk_size: int = 4000, overlap: int = 200)

    def scan_files(self, path: str, filters: FileFilters) -> List[str]
        """æ‰«æç›®å½•ï¼Œè¿”å›ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶åˆ—è¡¨"""

    def chunk_file(self, file_path: str) -> List[CodeChunk]
        """å°†å¤§æ–‡ä»¶åˆ†å—"""

    def is_checkable(self, file_path: str) -> bool
        """åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å¯æ£€æŸ¥"""
```

### ProgressTracker

```python
class ProgressTracker:
    def __init__(self, state_dir: str = ".auto-coder/codecheck/progress")

    def start_check(self, files: List[str], config: Dict) -> str
        """å¼€å§‹æ–°çš„æ£€æŸ¥ï¼Œè¿”å› check_id"""

    def mark_completed(self, check_id: str, file_path: str) -> None
        """æ ‡è®°æ–‡ä»¶å·²å®Œæˆæ£€æŸ¥"""

    def get_remaining_files(self, check_id: str) -> List[str]
        """è·å–å¾…æ£€æŸ¥çš„æ–‡ä»¶åˆ—è¡¨"""

    def save_state(self, check_id: str, state: CheckState) -> None
        """ä¿å­˜æ£€æŸ¥çŠ¶æ€"""

    def load_state(self, check_id: str) -> Optional[CheckState]
        """åŠ è½½æ£€æŸ¥çŠ¶æ€"""
```

### ReportGenerator

```python
class ReportGenerator:
    def __init__(self, output_dir: str = "codecheck")

    def generate_file_report(
        self, result: FileCheckResult, report_dir: str
    ) -> None
        """ç”Ÿæˆå•ä¸ªæ–‡ä»¶çš„æ£€æŸ¥æŠ¥å‘Š"""

    def generate_summary_report(
        self, results: List[FileCheckResult], report_dir: str
    ) -> None
        """ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š"""
```

---

## æµ‹è¯•æŒ‡å—

### å•å…ƒæµ‹è¯•

**æµ‹è¯•æ–‡ä»¶ä½ç½®**ï¼š`tests/checker/`

**æµ‹è¯•ç¤ºä¾‹**ï¼š

```python
# tests/checker/test_rules_loader.py

import pytest
from autocoder.checker.rules_loader import RulesLoader
from autocoder.checker.types import Rule, Severity

def test_load_backend_rules():
    """æµ‹è¯•åŠ è½½åç«¯è§„åˆ™"""
    loader = RulesLoader()
    rules = loader.load_rules("backend")

    assert len(rules) > 0
    assert all(isinstance(r, Rule) for r in rules)
    assert all(r.id.startswith("backend_") for r in rules)

def test_get_applicable_rules_for_python():
    """æµ‹è¯• Python æ–‡ä»¶è§„åˆ™é€‰æ‹©"""
    loader = RulesLoader()
    rules = loader.get_applicable_rules("test.py")

    assert len(rules) > 0
    assert all(r.id.startswith("backend_") for r in rules)

def test_rule_caching():
    """æµ‹è¯•è§„åˆ™ç¼“å­˜"""
    loader = RulesLoader()

    rules1 = loader.load_rules("backend")
    rules2 = loader.load_rules("backend")

    # åº”è¯¥è¿”å›åŒä¸€ä¸ªå¯¹è±¡ï¼ˆç¼“å­˜ï¼‰
    assert rules1 is rules2
```

**è¿è¡Œæµ‹è¯•**ï¼š

```bash
# è¿è¡Œæ‰€æœ‰æ£€æŸ¥å™¨æµ‹è¯•
pytest tests/checker/ -v

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
pytest tests/checker/test_rules_loader.py -v

# æŸ¥çœ‹è¦†ç›–ç‡
pytest tests/checker/ --cov=autocoder/checker --cov-report=html
```

### é›†æˆæµ‹è¯•

```python
# tests/checker/test_integration.py

def test_full_check_workflow():
    """æµ‹è¯•å®Œæ•´çš„æ£€æŸ¥æµç¨‹"""
    # 1. åˆ›å»ºä¸´æ—¶æµ‹è¯•æ–‡ä»¶
    test_file = "test_code.py"
    with open(test_file, 'w') as f:
        f.write("""
def test_function():
    if True:
        if True:
            if True:
                if True:
                    pass  # åµŒå¥—è¿‡æ·±
        """)

    try:
        # 2. åˆå§‹åŒ–æ£€æŸ¥å™¨
        checker = CodeChecker(mock_llm, mock_args)

        # 3. æ‰§è¡Œæ£€æŸ¥
        result = checker.check_file(test_file)

        # 4. éªŒè¯ç»“æœ
        assert result.status == "success"
        assert len(result.issues) > 0

        # 5. éªŒè¯æŠ¥å‘Šç”Ÿæˆ
        report_gen = ReportGenerator()
        report_gen.generate_file_report(result, "test_reports")

        assert os.path.exists("test_reports/files/test_code_py.json")
        assert os.path.exists("test_reports/files/test_code_py.md")

    finally:
        # æ¸…ç†
        os.remove(test_file)
        shutil.rmtree("test_reports")
```

### Mock æµ‹è¯•

```python
from unittest.mock import Mock, patch

def test_check_with_mock_llm():
    """ä½¿ç”¨ Mock LLM æµ‹è¯•"""
    # Mock LLM è¿”å›
    mock_llm = Mock()
    mock_llm.chat_oai.return_value = [Mock(output="""
    ```json
    [
        {
            "rule_id": "backend_001",
            "severity": "error",
            "line_start": 10,
            "line_end": 15,
            "description": "æµ‹è¯•é—®é¢˜",
            "suggestion": "æµ‹è¯•å»ºè®®"
        }
    ]
    ```
    """)]

    # æ‰§è¡Œæ£€æŸ¥
    checker = CodeChecker(mock_llm, mock_args)
    result = checker.check_file("test.py")

    # éªŒè¯
    assert result.status == "success"
    assert len(result.issues) == 1
    assert result.issues[0].rule_id == "backend_001"
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. è§„åˆ™ç¼“å­˜

```python
# ä½¿ç”¨ LRU ç¼“å­˜
from functools import lru_cache

class RulesLoader:
    @lru_cache(maxsize=10)
    def load_rules(self, rule_type: str) -> List[Rule]:
        # åŠ è½½é€»è¾‘
        pass
```

### 2. å¹¶å‘ä¼˜åŒ–

```python
# åŠ¨æ€è°ƒæ•´å¹¶å‘æ•°
def get_optimal_workers(file_count: int) -> int:
    if file_count < 10:
        return 2
    elif file_count < 50:
        return 5
    else:
        return 10
```

### 3. å¢é‡æ£€æŸ¥

```python
# åªæ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶
def get_changed_files() -> List[str]:
    result = subprocess.run(
        ["git", "diff", "--name-only", "HEAD"],
        capture_output=True,
        text=True
    )
    return result.stdout.strip().split('\n')
```

---

## å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•è°ƒè¯• LLM Promptï¼Ÿ

**A**: å¯ç”¨æ—¥å¿—è®°å½•ï¼š

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("autocoder.checker")

# æŸ¥çœ‹ LLM è¯·æ±‚å’Œå“åº”
logger.debug(f"LLM Request: {prompt}")
logger.debug(f"LLM Response: {response}")
```

### Q2: å¦‚ä½•ä¼˜åŒ–æ£€æŸ¥é€Ÿåº¦ï¼Ÿ

**A**:
1. å¢åŠ å¹¶å‘æ•°
2. å‡å°‘è§„åˆ™æ•°é‡
3. ä½¿ç”¨æ›´å¿«çš„æ¨¡å‹
4. å®ç°ç»“æœç¼“å­˜

### Q3: å¦‚ä½•å¤„ç†æ£€æŸ¥ç»“æœä¸å‡†ç¡®ï¼Ÿ

**A**:
1. ä¼˜åŒ– Prompt æ¨¡æ¿
2. æ·»åŠ æ›´å¤šç¤ºä¾‹åˆ°è§„åˆ™
3. ä½¿ç”¨æ›´å¼ºçš„æ¨¡å‹
4. ç»“åˆé™æ€åˆ†æå·¥å…·

---

## è´¡çŒ®æŒ‡å—

æ¬¢è¿è´¡çŒ®ä»£ç å’Œæ”¹è¿›å»ºè®®ï¼

### å¼€å‘æµç¨‹

1. Fork é¡¹ç›®
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯
3. ç¼–å†™ä»£ç å’Œæµ‹è¯•
4. æäº¤ Pull Request

### ä»£ç è§„èŒƒ

- éµå¾ª PEP 8
- æ·»åŠ ç±»å‹æ³¨è§£
- ç¼–å†™æ–‡æ¡£å­—ç¬¦ä¸²
- æ·»åŠ å•å…ƒæµ‹è¯•

---

**æœ€åæ›´æ–°**ï¼š2025-10-10
**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0.0
**ä½œè€…**ï¼šClaude AI
