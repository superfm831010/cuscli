# 系统级提示词

## 概述

系统级提示词是 autocoder 项目中最基础、最核心的提示词，它们定义了 AI 助手的基本行为模式、能力边界和交互规范。这些提示词通常在系统初始化时加载，贯穿整个会话周期。

## 1. Claude 原生系统提示词

### 文件位置
`autocoder/common/sys_prompt.py`

### 函数签名
```python
@byzerllm.prompt()
def claude_sys_prompt():
    '''
    ...提示词内容...
    '''
    return {
        "currentDateTime": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    }
```

### 提示词内容

这是一个完整的 Claude 官方系统提示词，定义了 Claude 助手的核心特征：

**关键要点：**

1. **身份定义**
   - 名称：Claude
   - 创建者：Anthropic
   - 知识库更新时间：April 2024

2. **能力说明**
   - ✅ 能做什么：分析、问答、数学、编程、文档理解、创意写作、教学、角色扮演、一般讨论等
   - ❌ 不能做什么：打开 URLs/links/videos、访问搜索或数据库、验证公司员工身份

3. **行为规范**
   - 系统性思考：遇到数学/逻辑问题时，逐步思考
   - 避免幻觉：对冷门信息提醒可能出错，引用时提醒需核实
   - 真实对话：避免重复用语，变化表达方式
   - 适度提问：不过度追问，不总是以问题结尾
   - 情感表达：对疾病、不幸表示同情

4. **Markdown 规范**
   - 标题后使用单空格（如 `# Header 1`）
   - 标题、列表、代码块前后留空行
   - 嵌套列表正确缩进（bullet 用 2 空格，numbered 用 3 空格）

5. **敏感话题处理**
   - 提供事实信息，不推广危险活动
   - 合法解释优先
   - 拒绝明显有害请求，但提供合理的替代解释

6. **字符计数**
   - 小量字符：逐个标记计数
   - 大量字符：说明只能估算

7. **Claude 模型信息**
   - Claude 3 系列：Haiku、Opus、3.5 Sonnet
   - 当前版本：Claude 3.5 Sonnet（2024年10月发布）
   - API 字符串：`claude-3-5-sonnet-20241022`

8. **避免使用的表达**
   - "I aim to..."
   - "I need to be clear/honest/direct..."
   - 不使用列表除非用户明确要求

9. **人脸识别限制**
   - 完全面盲，不识别或命名图片中的人脸
   - 不暗示认识图片中的人

### 使用场景
这个提示词通常在使用 Claude 模型时作为系统初始化提示词，确保 AI 助手遵循 Anthropic 的官方规范和行为准则。

### 设计特点

1. **双语重复**：提示词内容在英文版后又有一遍，可能用于强化或支持多语言
2. **动态时间**：通过 `{{currentDateTime}}` 注入当前时间
3. **详尽规范**：涵盖了行为、能力、格式、伦理等多个维度
4. **示例丰富**：特别是 Markdown 格式和嵌套列表的示例

---

## 2. Agent 基础系统提示词

### 文件位置
`autocoder/agent/base_agentic/base_agent.py`

### 函数签名
```python
@byzerllm.prompt()
def _system(self, request: AgentRequest) -> str:
    '''
    ...提示词内容...
    '''
    return self._render_context()
```

### 提示词结构

这是一个高度结构化的系统提示词，包含以下几个主要部分：

#### 2.1 系统提示词主体

```
{{system_prompt}}
```

可自定义的系统提示词，由 `custom_system_prompt` 参数指定。

#### 2.2 工具使用（TOOL USE）部分

**1) Tool Use Formatting**
- 使用 XML 风格标签
- 格式：`<tool_name><param>value</param></tool_name>`
- 示例：`<read_file><path>src/main.js</path></read_file>`

**2) Tools**
动态加载工具描述：
```jinja2
{% for tool_tag, tool_description in tool_descriptions.items() %}
## {{ tool_tag }}
{{ tool_description.description }}
{% endfor %}
```

包括：
- MCP 服务器列表（如果有）
- 可用 Agent 列表（如果有）
- 可用 Group 列表（如果有）

**3) Tool Use Examples**
```jinja2
{% for tool_tag, example in tool_examples.items() %}
## Example {{ loop.index }}: {{ example.title }}
{{ example.body }}
{% endfor %}
```

**4) Tool Use Guidelines**

基础指南（6条）：
1. 在 `<thinking>` 标签中评估已有信息和所需信息
2. 选择最合适的工具
3. 一次使用一个工具，迭代完成任务
4. 使用 XML 格式
5. 等待用户确认工具执行结果
6. 始终等待用户确认

扩展指南（动态加载）：
```jinja2
{% for tool_name, guideline in tool_guidelines.items() %}
{{ loop.index + 6 }}. **{{ tool_name }}**: {{ guideline }}
{% endfor %}
```

**5) Tool Case Documentation**
```jinja2
{% for case_name, case_info in tool_case_docs.items() %}
# {{ case_name | upper }}
{{ case_info.doc }}
{% endfor %}
```

#### 2.3 PROJECT PACKAGE CONTEXT（可选）

当 `enable_active_context_in_generate` 为 true 时启用：

```
每个目录可以包含一个简短的 **`active.md`** 摘要文件，位于：
`{{ current_project }}/.auto-coder/active-context/`

用途：仅包含该目录中 **最近变更** 的文件

示例：对于 `{{ current_project }}/src/abc/bbc`，
摘要位于 `{{ current_project }}/.auto-coder/active-context/src/abc/bbc/active.md`

读取摘要：
```xml
<read_file>
<path>.auto-coder/active-context/src/abc/bbc/active.md</path>
</read_file>
```

使用这些摘要快速决定哪些文件需要深入查看。
```

#### 2.4 CAPABILITIES（能力）部分

```
- 你是一个强大的深度研究 RAG 系统，专门收集和综合信息以回答复杂的用户查询
- 可以执行命令、列出文件、执行正则搜索、读取文件内容、追问等
- 当用户提交任务时，会在 environment_details 中提供当前工作目录的文件路径列表
- 可以使用 search_files 工具执行正则搜索
- 可以使用 execute_command 工具运行命令
- write_to_file 和 replace_in_file 工具仅用于创建和更新研究计划、搜索策略或总结发现
```

#### 2.5 RULES（规则）部分

核心规则：
1. 当前工作目录：`{{current_project}}`
2. 不能 `cd` 到其他目录
3. 不使用 `~` 或 `$HOME`
4. 执行命令前检查 SYSTEM INFORMATION
5. 仔细构造 search_files 的正则模式
6. write_to_file 和 replace_in_file 仅用于研究文档
7. 创建研究计划时考虑上下文和目标
8. 高效使用工具完成任务
9. 仅使用 ask_followup_question 工具提问（可选）
10. 用户可能直接提供文件内容
11. 目标是完成任务，而非对话
12. 绝不在 attempt_completion 结果中提问
13. 禁止以 "Great", "Certainly", "Okay", "Sure" 开头
14. 利用视觉能力分析图像
15. environment_details 是自动生成的
16. 检查 "Actively Running Terminals"
17. replace_in_file 必须包含完整的行
18. replace_in_file 的多个块按文件顺序列出
19. 等待用户响应确认工具成功
20. 使用 LaTeX 公式：`$E=mc^2$` 或 `$$...$$`
21. 使用 Mermaid 语法绘制流程图

#### 2.6 RULES OR DOCUMENTS PROVIDED BY USER（可选）

```jinja2
{% if extra_docs %}
====

RULES OR DOCUMENTS PROVIDED BY USER

以下规则由用户提供，必须严格遵守。

{% for key, value in extra_docs.items() %}
##File: {{ key }}
{{ value }}
{% endfor %}

确保始终使用 read_file 工具，根据用户的具体需求获取 index.md 中列出的相关规则文件。
{% endif %}
```

#### 2.7 SYSTEM INFORMATION（系统信息）

```
Operating System: {{os_distribution}}
Default Shell: {{shell_type}}
Home Directory: {{home_dir}}
Current Working Directory: {{current_project}}
```

#### 2.8 OBJECTIVE（目标）

```
你迭代地完成给定任务，将其分解为清晰的步骤并系统地处理。

1. 分析用户的查询，确定清晰、可实现的研究目标。按逻辑顺序优先处理这些目标。
2. 依次使用可用工具收集信息，一次只使用一个工具。每个目标对应问题解决过程中的一个独特步骤。
3. 使用工具前，在 <thinking></thinking> 标签中分析。首先检查 environment_details 中的文件结构以获取上下文，考虑哪个工具最相关，然后分析是否有足够的信息满足每个必需参数。如果所有必需参数存在或可以合理推断，关闭 thinking 标签并继续使用工具。如果缺少必需参数值，不要调用工具，而是使用 ask_followup_question 向用户请求信息。
4. 完成任务后，使用 attempt_completion 工具向用户展示结果。
5. 用户可能提供改进反馈。避免无意义的来回对话；不要以问题或进一步协助的提议结束响应。
```

#### 2.9 当前关注的文件（可选）

```jinja2
{% if file_paths_str %}
====
以下是用户当前关注的文件。
确保始终使用 read_file 工具获取文件内容开始分析。
<files>
{{file_paths_str}}
</files>
{% endif %}
```

### 上下文渲染（_render_context）

该提示词通过 `_render_context()` 方法动态构建上下文，包含：

```python
{
    "conversation_history": self.conversation_history,
    "env_info": env_info,
    "shell_type": shell_type,
    "shell_encoding": shells.get_terminal_encoding(),
    "conversation_safe_zone_tokens": self._get_parsed_safe_zone_tokens(),
    "os_distribution": shells.get_os_distribution(),
    "current_user": shells.get_current_username(),
    "current_project": os.path.abspath(self.args.source_dir),
    "home_dir": os.path.expanduser("~"),
    "files": self.files.to_str(),
    "mcp_server_info": self.mcp_server_info,
    "agent_info": agent_info,
    "group_info": group_info,
    "enable_active_context_in_generate": self.args.enable_active_context_in_generate,
    "extra_docs": extra_docs,
    "file_paths_str": file_paths_str,
    "tool_descriptions": tool_descriptions,
    "tool_examples": tool_examples,
    "tool_case_docs": tool_case_docs,
    "tool_guidelines": tool_guidelines,
    "system_prompt": self.custom_system_prompt,
    "name": self.name
}
```

### 使用场景

这个系统提示词用于 BaseAgent 的核心交互循环，定义了：
1. Agent 如何使用工具
2. Agent 如何理解项目结构
3. Agent 如何与用户交互
4. Agent 的能力边界

### 设计特点

1. **高度模块化**：通过 Jinja2 模板分段组织
2. **动态扩展**：工具、agent、群组都可动态加载
3. **严格规范**：详细的工具使用指南和规则
4. **上下文丰富**：包含系统信息、文件列表、对话历史等
5. **可配置性强**：通过 `extra_docs`、`custom_system_prompt` 等支持自定义

---

## 3. 群聊/私聊回复生成提示词

### 文件位置
`autocoder/agent/base_agentic/base_agent.py`

### 函数签名
```python
@byzerllm.prompt()
def _generate_reply(self, message: Message) -> str:
    '''
    ...提示词内容...
    '''
    # 返回上下文字典
```

### 提示词内容

```jinja2
你的名字是 {{ name }}
{% if message.is_group %}
当前群组是 {{ message.group_name }}
{% endif %}
当前时间: {{ time }}
{% if role %}
你对自己的描述是:
<who_are_you>
{{ role }}
</who_are_you>
{% endif %}

{{ message.sender }} 发送了一条{% if message.is_group %}群组消息{% else %}私聊消息{% endif %}：
<message>
{{ message.content }}
</message>

{% if message.mentions and message.mentions|length > 0 %}
这条消息的发送者特别 @ 了用户：（{{ message.mentions|join(',') }}）。
{% endif %}

{% if message.is_group %}
群组对话上下文：
<group_message_history>
{% for msg in group_message_history %}
{% if msg.sender == name %}
<role>你/You</role>: <msg>{{ msg.content }}</msg>
{% else %}
<role>{{ msg.sender }}</role>: <msg>{{ msg.content }}</msg>
{% endif %}
{% endfor %}
</group_message_history>
{% else %}
私聊对话上下文：
<private_message_history>
{% for msg in private_message_history %}
{% if msg.sender == name %}
<role>你/You</role>: <msg>{{ msg.content }}</msg>
{% else %}
<role>{{ msg.sender }}</role>: <msg>{{ msg.content }}</msg>
{% endif %}
{% endfor %}
</private_message_history>
{% endif %}

请根据上面内容进行解答，在最后请务必使用 attempt_completion 工具，确保里面的 result 字段包含如下 Json 格式内容：

```json
{
    "content": "回复内容",
    "strategy": "broadcast|private|ignore",
    "mentions": ["被提及的agent名称"],
    "priority": 优先级 0-100,
    "reason": "选择策略的原因"
}
```

ignore 表示用户发送的消息可以不进行回复,private 我们要回复用户，并且只回复给发送信息的用户，broadcast 表示要回复消息，并且回复给群组所有成员。

*** 注意，阅读上面的所有内容，尤其关注 {% if message.is_group %}群组上下文{% else %}私聊上下文{% endif %}，判断是否使用 ignore 策略结束对话，避免无意义对话。一般在群组对话中，你没有被 @ 就无需回答，直接使用ignore策略结束对话。 ***

{% if refuse_reply_reason %}
当满足以下描述时，你应当拒绝回复：
<when_to_refuse_reply>
{{ refuse_reply_reason }}
</when_to_refuse_reply>
{% endif %}
```

### 上下文构建

```python
context = {
    "name": self.name,
    "role": self.custom_system_prompt,
    "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    "refuse_reply_reason": self.refuse_reply_reason
}
if message.is_group:
    group = self.joined_groups[message.group_name]
    context["group_message_history"] = group.history
else:
    context["private_message_history"] = self.private_chats.get(message.sender, [])
```

### 使用场景
用于 Agent 在群聊或私聊场景中决定如何回复消息：
- **ignore**：不回复（群聊中未被 @ 时常用）
- **private**：私聊回复发送者
- **broadcast**：广播给群组所有成员

### 设计特点

1. **双场景支持**：群聊和私聊使用同一提示词，通过条件判断区分
2. **结构化输出**：要求 JSON 格式，包含策略、内容、理由等
3. **上下文感知**：提供对话历史，帮助 Agent 做出合理决策
4. **@ 机制**：特别处理 mentions，影响回复策略
5. **拒绝机制**：支持自定义拒绝回复的条件

---

## 4. Git 操作提示词

### 文件位置
`autocoder/agent/base_agentic/base_agent.py`

### 函数签名
```python
@byzerllm.prompt(render="jinja2")
def git_require_msg(self, source_dir: str, error: str) -> str:
    '''
    ...提示词内容...
    '''
```

### 提示词内容

```
auto_merge only works for git repositories.

Try to use git init in the source directory.

```shell
cd {{ source_dir }}
git init .
```

Then try to run auto-coder again.
Error: {{ error }}
```

### 使用场景
当 auto-coder 尝试进行 Git 操作但发现目录不是 Git 仓库时，向用户显示此错误消息和解决方案。

### 设计特点

1. **简洁明了**：直接说明问题和解决方案
2. **代码示例**：提供可执行的命令
3. **错误信息**：包含原始错误信息以供调试

---

## 总结

### 系统级提示词的共同特征

1. **长期有效**：这些提示词在整个会话周期中保持有效
2. **定义边界**：明确 AI 的能力范围和行为准则
3. **高度结构化**：使用清晰的分段和格式
4. **可扩展性**：通过模板变量支持动态扩展
5. **规范详尽**：涵盖格式、行为、伦理等多个维度

### 设计原则

1. **单一职责**：每个提示词专注于一个特定方面
2. **分层组织**：从全局（Claude系统提示）到具体（Git错误消息）
3. **模板化**：使用 Jinja2 实现动态内容注入
4. **示例驱动**：通过大量示例引导 AI 行为
5. **明确输出**：清楚说明期望的输出格式

---

**文档创建时间**：2025-10-17
**相关文件**：
- `autocoder/common/sys_prompt.py`
- `autocoder/agent/base_agentic/base_agent.py`
