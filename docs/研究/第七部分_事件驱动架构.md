# ç¬¬ä¸ƒéƒ¨åˆ†ï¼šäº‹ä»¶é©±åŠ¨æ¶æ„ï¼ˆæ ¸å¿ƒäº®ç‚¹ï¼‰

**åˆ›å»ºæ—¶é—´**: 2025-10-17
**åŸºäºä»£ç ç‰ˆæœ¬**: auto-coder 1.0.39
**éªŒè¯çŠ¶æ€**: âœ… 100%å‡†ç¡®ï¼ˆåŸºäºå®é™…ä»£ç ï¼‰

---

## æ¦‚è¿°

äº‹ä»¶é©±åŠ¨æ¶æ„æ˜¯ autocoder agentic agent ç³»ç»Ÿçš„æ ¸å¿ƒè®¾è®¡ä¹‹ä¸€ï¼Œè´¯ç©¿æ•´ä¸ªç³»ç»Ÿçš„è¿è¡Œæµç¨‹ã€‚é€šè¿‡äº‹ä»¶æœºåˆ¶å®ç°äº†ï¼š

1. **ç»„ä»¶è§£è€¦**ï¼šå„ç»„ä»¶é€šè¿‡äº‹ä»¶é€šä¿¡ï¼Œé™ä½è€¦åˆåº¦
2. **å®æ—¶åé¦ˆ**ï¼šæµå¼è¾“å‡ºï¼Œç”¨æˆ·å®æ—¶çœ‹åˆ°è¿›å±•
3. **å¯æ‰©å±•æ€§**ï¼šé€šè¿‡å›è°ƒç³»ç»Ÿè½»æ¾æ‰©å±•åŠŸèƒ½
4. **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„äº‹ä»¶è¿½è¸ªå’Œæ—¥å¿—è®°å½•

---

## 7.1 äº‹ä»¶ç±»å‹ç³»ç»Ÿ

### 7.1.1 äº‹ä»¶ç±»å‹æ¦‚è§ˆ

autocoder å®šä¹‰äº†ä¸°å¯Œçš„äº‹ä»¶ç±»å‹æ¥è¡¨ç¤ºä¸åŒçš„ç³»ç»ŸçŠ¶æ€å’Œè¡Œä¸ºï¼š

```python
# autocoder/agent/base_agentic/types.py

# æ ¸å¿ƒäº‹ä»¶ç±»å‹
class LLMOutputEvent(BaseModel):
    """LLM æ™®é€šæ–‡æœ¬è¾“å‡º"""
    text: str

class LLMThinkingEvent(BaseModel):
    """LLM thinking æ ‡ç­¾å†…å®¹"""
    text: str

class ToolCallEvent(BaseModel):
    """å·¥å…·è°ƒç”¨äº‹ä»¶"""
    tool: SkipValidation[BaseTool]
    tool_xml: str

class ToolResultEvent(BaseModel):
    """å·¥å…·æ‰§è¡Œç»“æœ"""
    tool_name: str
    result: ToolResult

class TokenUsageEvent(BaseModel):
    """Token ä½¿ç”¨ç»Ÿè®¡"""
    usage: Any

class CompletionEvent(BaseModel):
    """ä»»åŠ¡å®Œæˆäº‹ä»¶"""
    completion: Any
    completion_xml: str

class ErrorEvent(BaseModel):
    """é”™è¯¯äº‹ä»¶"""
    message: str

class RetryEvent(BaseModel):
    """é‡è¯•äº‹ä»¶"""
    message: str

class PlanModeRespondEvent(BaseModel):
    """è®¡åˆ’æ¨¡å¼å“åº”"""
    completion: SkipValidation[PlanModeRespondTool]
    completion_xml: str

class WindowLengthChangeEvent(BaseModel):
    """ä¸Šä¸‹æ–‡çª—å£é•¿åº¦å˜åŒ–"""
    tokens_used: int
    pruned_tokens_used: int
    conversation_round: int

class ConversationIdEvent(BaseModel):
    """å¯¹è¯IDäº‹ä»¶"""
    conversation_id: str

# äº‹ä»¶è”åˆç±»å‹
AgentEvent = Union[
    LLMOutputEvent,
    LLMThinkingEvent,
    ToolCallEvent,
    ToolResultEvent,
    TokenUsageEvent,
    CompletionEvent,
    ErrorEvent,
    RetryEvent,
    PlanModeRespondEvent,
    WindowLengthChangeEvent,
    ConversationIdEvent
]
```

### 7.1.2 äº‹ä»¶åˆ†ç±»

**æŒ‰åŠŸèƒ½åˆ†ç±»**ï¼š

| åˆ†ç±» | äº‹ä»¶ç±»å‹ | è¯´æ˜ |
|------|---------|------|
| **LLMè¾“å‡º** | LLMOutputEvent, LLMThinkingEvent | å±•ç¤ºLLMç”Ÿæˆå†…å®¹ |
| **å·¥å…·ç›¸å…³** | ToolCallEvent, ToolResultEvent | å·¥å…·è°ƒç”¨å’Œç»“æœ |
| **æµç¨‹æ§åˆ¶** | CompletionEvent, RetryEvent | æ§åˆ¶æ‰§è¡Œæµç¨‹ |
| **ç›‘æ§ç»Ÿè®¡** | TokenUsageEvent, WindowLengthChangeEvent | æ€§èƒ½å’Œæˆæœ¬ç›‘æ§ |
| **é”™è¯¯å¤„ç†** | ErrorEvent | å¼‚å¸¸å’Œé”™è¯¯ |
| **å…ƒä¿¡æ¯** | ConversationIdEvent | å¯¹è¯ç®¡ç†ä¿¡æ¯ |

**æŒ‰è§¦å‘æ—¶æœºåˆ†ç±»**ï¼š

```
å¯¹è¯å¼€å§‹
  â†“
  ConversationIdEvent - å¯¹è¯IDåˆ›å»º
  â†“
å¯¹è¯å¾ªç¯å¼€å§‹
  â†“
  WindowLengthChangeEvent - ä¸Šä¸‹æ–‡å‰ªè£ç»Ÿè®¡
  â†“
  LLMThinkingEvent - LLMæ€è€ƒè¿‡ç¨‹ï¼ˆå¯é€‰ï¼‰
  â†“
  LLMOutputEvent - LLMæ–‡æœ¬è¾“å‡º
  â†“
  ToolCallEvent - LLMå†³å®šè°ƒç”¨å·¥å…·
  â†“
  ToolResultEvent - å·¥å…·æ‰§è¡Œç»“æœ
  â†“
  TokenUsageEvent - Tokenä½¿ç”¨ç»Ÿè®¡
  â†“
  ï¼ˆå¾ªç¯ï¼‰æˆ– CompletionEvent - ä»»åŠ¡å®Œæˆ
  â†“
å¯¹è¯ç»“æŸ
```

### 7.1.3 äº‹ä»¶æ•°æ®ç»“æ„è¯¦è§£

#### LLMOutputEvent - æ™®é€šæ–‡æœ¬è¾“å‡º

```python
class LLMOutputEvent(BaseModel):
    """
    è¡¨ç¤ºLLMçš„çº¯æ–‡æœ¬è¾“å‡º

    è§¦å‘æ—¶æœºï¼š
    - æµå¼è§£æåˆ°æ™®é€šæ–‡æœ¬æ—¶
    - ä¸åœ¨<thinking>æ ‡ç­¾å†…
    - ä¸åœ¨å·¥å…·è°ƒç”¨æ ‡ç­¾å†…

    ç”¨é€”ï¼š
    - å®æ—¶å±•ç¤ºLLMå›å¤
    - ç´¯ç§¯åˆ°assistantæ¶ˆæ¯
    """
    text: str  # æ–‡æœ¬ç‰‡æ®µ

# ä½¿ç”¨ç¤ºä¾‹
event = LLMOutputEvent(text="I'm analyzing the code...")
print(event.text, end="")  # å®æ—¶è¾“å‡ºï¼Œä¸æ¢è¡Œ
```

#### LLMThinkingEvent - æ€è€ƒè¿‡ç¨‹

```python
class LLMThinkingEvent(BaseModel):
    """
    è¡¨ç¤ºLLMçš„æ€è€ƒè¿‡ç¨‹

    è§¦å‘æ—¶æœºï¼š
    - è§£æåˆ°<thinking>...</thinking>å†…å®¹

    ç”¨é€”ï¼š
    - å±•ç¤ºLLMæ¨ç†è¿‡ç¨‹
    - å¸®åŠ©ç”¨æˆ·ç†è§£å†³ç­–
    - è°ƒè¯•å’Œå®¡è®¡
    """
    text: str  # æ€è€ƒå†…å®¹

# ä½¿ç”¨ç¤ºä¾‹
event = LLMThinkingEvent(text="I need to read the file first...")
console.print(f"[grey50]{event.text}[/grey50]")  # ç”¨ç°è‰²æ˜¾ç¤ºæ€è€ƒ
```

#### ToolCallEvent - å·¥å…·è°ƒç”¨

```python
class ToolCallEvent(BaseModel):
    """
    è¡¨ç¤ºLLMå†³å®šè°ƒç”¨å·¥å…·

    è§¦å‘æ—¶æœºï¼š
    - è§£æåˆ°å®Œæ•´çš„å·¥å…·è°ƒç”¨XML
    - å·¥å…·å¯¹è±¡åˆ›å»ºæˆåŠŸ

    ç”¨é€”ï¼š
    - å±•ç¤ºå³å°†æ‰§è¡Œçš„å·¥å…·
    - æ‰§è¡Œå·¥å…·å‰çš„å®¡æ‰¹ï¼ˆå¯é€‰ï¼‰
    - è®°å½•å·¥å…·è°ƒç”¨å†å²
    """
    tool: SkipValidation[BaseTool]  # å·¥å…·å¯¹è±¡
    tool_xml: str  # é‡æ„åçš„XML

# ä½¿ç”¨ç¤ºä¾‹
event = ToolCallEvent(
    tool=ReadFileTool(path="src/main.py"),
    tool_xml="<read_file>\n<path>src/main.py</path>\n</read_file>"
)
print(f"Calling tool: {type(event.tool).__name__}")
print(f"Parameters: {event.tool.model_dump()}")
```

#### ToolResultEvent - å·¥å…·ç»“æœ

```python
class ToolResultEvent(BaseModel):
    """
    è¡¨ç¤ºå·¥å…·æ‰§è¡Œç»“æœ

    è§¦å‘æ—¶æœºï¼š
    - å·¥å…·æ‰§è¡Œå®Œæˆ
    - æ— è®ºæˆåŠŸæˆ–å¤±è´¥

    ç”¨é€”ï¼š
    - å±•ç¤ºå·¥å…·æ‰§è¡Œç»“æœ
    - æ·»åŠ åˆ°å¯¹è¯å†å²
    - ä¾›LLMä¸‹ä¸€è½®ä½¿ç”¨
    """
    tool_name: str  # å·¥å…·åç§°
    result: ToolResult  # æ‰§è¡Œç»“æœ

# ä½¿ç”¨ç¤ºä¾‹
event = ToolResultEvent(
    tool_name="ReadFileTool",
    result=ToolResult(
        success=True,
        message="Successfully read file",
        content="file content here..."
    )
)
if event.result.success:
    print(f"âœ“ {event.result.message}")
else:
    print(f"âœ— {event.result.message}")
```

#### TokenUsageEvent - Tokenç»Ÿè®¡

```python
class TokenUsageEvent(BaseModel):
    """
    è¡¨ç¤ºTokenä½¿ç”¨æƒ…å†µ

    è§¦å‘æ—¶æœºï¼š
    - LLMå“åº”æµç»“æŸæ—¶
    - åŒ…å«è¾“å…¥å’Œè¾“å‡ºtokenæ•°

    ç”¨é€”ï¼š
    - è®¡ç®—APIæˆæœ¬
    - ç›‘æ§tokenä½¿ç”¨
    - ä¼˜åŒ–ä¸Šä¸‹æ–‡ç®¡ç†
    """
    usage: Any  # LLMMetadataå¯¹è±¡

# ä½¿ç”¨ç¤ºä¾‹ï¼ˆåœ¨BaseAgent.run_with_generatorä¸­ï¼‰
if isinstance(event, TokenUsageEvent):
    model_name = ",".join(llm_utils.get_llm_names(self.llm))
    model_info = llm_utils.get_model_info(model_name, self.args.product_mode)

    input_price = model_info.get("input_price", 0.0)
    output_price = model_info.get("output_price", 0.0)

    input_cost = (event.usage.input_tokens_count * input_price) / 1000000
    output_cost = (event.usage.generated_tokens_count * output_price) / 1000000

    logger.info(f"Token usage: {event.usage.input_tokens_count} in, "
                f"{event.usage.generated_tokens_count} out, "
                f"cost: ${input_cost + output_cost:.6f}")
```

#### CompletionEvent - ä»»åŠ¡å®Œæˆ

```python
class CompletionEvent(BaseModel):
    """
    è¡¨ç¤ºä»»åŠ¡å®Œæˆ

    è§¦å‘æ—¶æœºï¼š
    - LLMè°ƒç”¨attempt_completionå·¥å…·
    - åŒ…å«æœ€ç»ˆç»“æœ

    ç”¨é€”ï¼š
    - ç»“æŸå¯¹è¯å¾ªç¯
    - å±•ç¤ºæœ€ç»ˆç»“æœ
    - è§¦å‘åç»­åŠ¨ä½œï¼ˆcommitç­‰ï¼‰
    """
    completion: Any  # AttemptCompletionTool
    completion_xml: str

# ä½¿ç”¨ç¤ºä¾‹
event = CompletionEvent(
    completion=AttemptCompletionTool(
        result="Task completed successfully! The refactoring is done.",
        command="npm test"  # å¯é€‰çš„åç»­å‘½ä»¤
    ),
    completion_xml="<attempt_completion>...</attempt_completion>"
)
print("âœ“ Task completed!")
print(event.completion.result)
if event.completion.command:
    print(f"Suggested command: {event.completion.command}")
```

#### WindowLengthChangeEvent - çª—å£å˜åŒ–

```python
class WindowLengthChangeEvent(BaseModel):
    """
    è¡¨ç¤ºä¸Šä¸‹æ–‡çª—å£é•¿åº¦å˜åŒ–

    è§¦å‘æ—¶æœºï¼š
    - æ¯è½®å¯¹è¯å‰ï¼Œä¸Šä¸‹æ–‡å‰ªè£å

    ç”¨é€”ï¼š
    - ç›‘æ§ä¸Šä¸‹æ–‡å¢é•¿
    - è¯„ä¼°å‰ªè£æ•ˆæœ
    - è°ƒæ•´å‰ªè£ç­–ç•¥
    """
    tokens_used: int  # å‰ªè£å‰tokenæ•°
    pruned_tokens_used: int  # å‰ªè£åtokenæ•°
    conversation_round: int  # å½“å‰è½®æ¬¡

# ä½¿ç”¨ç¤ºä¾‹ï¼ˆåœ¨AgenticEdit.analyzeä¸­ï¼‰
yield WindowLengthChangeEvent(
    tokens_used=count_tokens(json.dumps(conversations)),
    pruned_tokens_used=count_tokens(json.dumps(pruned_conversations)),
    conversation_round=iteration_count
)

# æ¥æ”¶ç«¯è®¡ç®—å‹ç¼©æ¯”
event = ...  # WindowLengthChangeEvent
compression_ratio = event.pruned_tokens_used / event.tokens_used
logger.info(f"Round {event.conversation_round}: "
            f"Context: {event.tokens_used} -> {event.pruned_tokens_used} tokens "
            f"(compression: {(1-compression_ratio)*100:.1f}%)")
```

#### ErrorEvent & RetryEvent

```python
class ErrorEvent(BaseModel):
    """é”™è¯¯äº‹ä»¶"""
    message: str

class RetryEvent(BaseModel):
    """é‡è¯•äº‹ä»¶"""
    message: str

# ä½¿ç”¨ç¤ºä¾‹
# é”™è¯¯
try:
    result = tool.execute()
except Exception as e:
    yield ErrorEvent(message=f"Tool execution failed: {str(e)}")

# é‡è¯•ï¼ˆåœ¨æµå¼è§£æä¸­ï¼‰
if buffer and in_tool_block:
    # å·¥å…·å—æœªå®Œæ•´
    yield RetryEvent(message="Stream ended with unterminated tool block")
```

---

## 7.2 äº‹ä»¶æµå¤„ç†

### 7.2.1 äº‹ä»¶ç”Ÿæˆæµç¨‹

**åœ¨ BaseAgent.agentic_run() ä¸­**ï¼š

```python
def agentic_run(self, request: AgentRequest) -> Generator[AgentEvent, None, None]:
    """
    æ ¸å¿ƒå¯¹è¯å¾ªç¯ï¼Œç”Ÿæˆäº‹ä»¶æµ

    äº‹ä»¶ç”Ÿæˆé¡ºåºï¼š
    1. ConversationIdEventï¼ˆå¦‚æœé€‚ç”¨ï¼‰
    2. WindowLengthChangeEventï¼ˆæ¯è½®ï¼‰
    3. LLMThinkingEvent / LLMOutputEventï¼ˆæµå¼ï¼‰
    4. ToolCallEventï¼ˆå·¥å…·è°ƒç”¨ï¼‰
    5. ToolResultEventï¼ˆå·¥å…·ç»“æœï¼‰
    6. TokenUsageEventï¼ˆæ¯è½®ç»“æŸï¼‰
    7. CompletionEventï¼ˆä»»åŠ¡å®Œæˆï¼‰
    8. ErrorEventï¼ˆå‘ç”Ÿé”™è¯¯æ—¶ï¼‰
    """

    # ä¸»å¾ªç¯
    while iteration_count <= max_iterations:
        iteration_count += 1

        # Step 1: è°ƒç”¨LLM
        llm_response_gen = stream_chat_with_continue(...)

        # Step 2: æµå¼è§£æï¼Œç”Ÿæˆäº‹ä»¶
        parsed_events = self.stream_and_parse_llm_response(llm_response_gen)

        # Step 3: å¤„ç†äº‹ä»¶å¹¶è½¬å‘
        for event in parsed_events:
            if isinstance(event, (LLMOutputEvent, LLMThinkingEvent)):
                # ç«‹å³è½¬å‘ç»™ç”¨æˆ·ï¼Œå®ç°å®æ—¶è¾“å‡º
                yield event

            elif isinstance(event, ToolCallEvent):
                # è½¬å‘å·¥å…·è°ƒç”¨äº‹ä»¶
                yield event

                # æ‰§è¡Œå·¥å…·
                tool_result = resolver.resolve()

                # è½¬å‘å·¥å…·ç»“æœäº‹ä»¶
                yield ToolResultEvent(tool_name=..., result=tool_result)

                # æ£€æŸ¥æ˜¯å¦å®Œæˆ
                if isinstance(event.tool, AttemptCompletionTool):
                    yield CompletionEvent(completion=event.tool, ...)
                    return

            elif isinstance(event, TokenUsageEvent):
                # è½¬å‘Tokenç»Ÿè®¡äº‹ä»¶
                yield event

            elif isinstance(event, ErrorEvent):
                # è½¬å‘é”™è¯¯äº‹ä»¶
                yield event
```

**äº‹ä»¶æµç¤ºæ„å›¾**ï¼š

```
ç”¨æˆ·è¾“å…¥
    â†“
BaseAgent.agentic_run()  â†â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“                              â”‚
stream_and_parse_llm_response()   â”‚
    â†“                              â”‚
[äº‹ä»¶ç”Ÿæˆå™¨]                      â”‚ å¾ªç¯
    â†“                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚ LLMThinkingEvent    â”‚ â”€â”€â†’ yield â”‚
â”‚ LLMOutputEvent      â”‚ â”€â”€â†’ yield â”‚
â”‚ ToolCallEvent       â”‚ â”€â”€â†’ yield â”‚
â”‚   â†“ æ‰§è¡Œå·¥å…·          â”‚           â”‚
â”‚ ToolResultEvent     â”‚ â”€â”€â†’ yield â”‚
â”‚ TokenUsageEvent     â”‚ â”€â”€â†’ yield â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
    â”‚                              â”‚
    â”‚ æœªå®Œæˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
CompletionEvent â”€â”€â†’ yield
    â†“
ç»“æŸ
```

### 7.2.2 äº‹ä»¶æ¶ˆè´¹æ¨¡å¼

**æ¨¡å¼1ï¼šç»ˆç«¯å®æ—¶æ˜¾ç¤º**

```python
# BaseAgent.run_in_terminal()
console = Console()

for event in agent.agentic_run(request):
    if isinstance(event, LLMThinkingEvent):
        # ç°è‰²æ˜¾ç¤ºæ€è€ƒè¿‡ç¨‹
        console.print(f"[grey50]{event.text}[/grey50]", end="")

    elif isinstance(event, LLMOutputEvent):
        # æ­£å¸¸æ˜¾ç¤ºè¾“å‡º
        console.print(event.text, end="")

    elif isinstance(event, ToolCallEvent):
        # Panelæ˜¾ç¤ºå·¥å…·è°ƒç”¨
        tool_name = type(event.tool).__name__
        console.print(Panel(
            get_tool_display_message(event.tool),
            title=f"ğŸ”§ Tool: {tool_name}",
            border_style="blue"
        ))

    elif isinstance(event, ToolResultEvent):
        # Panelæ˜¾ç¤ºå·¥å…·ç»“æœ
        border_style = "green" if event.result.success else "red"
        console.print(Panel(
            f"{'âœ“' if event.result.success else 'âœ—'} {event.result.message}",
            border_style=border_style
        ))

    elif isinstance(event, CompletionEvent):
        # Markdownæ˜¾ç¤ºæœ€ç»ˆç»“æœ
        console.print(Panel(
            Markdown(event.completion.result),
            title="âœ“ Task Completed",
            border_style="green"
        ))

    elif isinstance(event, TokenUsageEvent):
        # åå°è®°å½•Tokenä½¿ç”¨
        logger.info(f"Token usage: {event.usage.input_tokens_count} in, "
                   f"{event.usage.generated_tokens_count} out")
```

**æ¨¡å¼2ï¼šSDKç»“æ„åŒ–è¿”å›**

```python
# runner/sdk_runner.py
def run(self, agent: AgenticEdit, request: AgenticEditRequest) -> Dict:
    result = {
        "success": False,
        "result": None,
        "events": [],
        "token_usage": None,
        "tool_calls": []
    }

    for event in agent.analyze(request):
        # è®°å½•æ‰€æœ‰äº‹ä»¶
        result["events"].append({
            "type": type(event).__name__,
            "timestamp": datetime.now().isoformat(),
            "data": event.model_dump()
        })

        # æå–å…³é”®ä¿¡æ¯
        if isinstance(event, ToolCallEvent):
            result["tool_calls"].append({
                "tool": type(event.tool).__name__,
                "params": event.tool.model_dump()
            })

        elif isinstance(event, TokenUsageEvent):
            result["token_usage"] = {
                "input": event.usage.input_tokens_count,
                "output": event.usage.generated_tokens_count
            }

        elif isinstance(event, CompletionEvent):
            result["success"] = True
            result["result"] = event.completion.result

    return result
```

**æ¨¡å¼3ï¼šæ–‡ä»¶äº‹ä»¶ç³»ç»Ÿ**

```python
# runner/file_based_event_runner.py
def run(self, agent: AgenticEdit, request: AgenticEditRequest):
    event_manager = get_event_manager(self.args.event_file)

    for event in agent.analyze(request):
        # è½¬æ¢ä¸ºæ ‡å‡†äº‹ä»¶æ ¼å¼
        if isinstance(event, LLMOutputEvent):
            event_manager.write_stream(
                content={"content": event.text},
                metadata={"type": "llm_output", "is_streaming": True}
            )

        elif isinstance(event, ToolCallEvent):
            event_manager.write_result(
                content={
                    "tool_name": type(event.tool).__name__,
                    **event.tool.model_dump()
                },
                metadata={"type": "tool_call"}
            )

        elif isinstance(event, CompletionEvent):
            event_manager.write_completion(
                content={"result": event.completion.result},
                metadata={"type": "completion"}
            )
```

---

## 7.3 å›è°ƒç³»ç»Ÿï¼ˆAgenticCallbacksï¼‰

### 7.3.1 å›è°ƒç³»ç»Ÿæ¦‚è¿°

å›è°ƒç³»ç»Ÿæä¾›äº†16ä¸ªç²¾å¿ƒè®¾è®¡çš„å›è°ƒç‚¹ï¼Œå…è®¸åœ¨å…³é”®æ—¶åˆ»æ³¨å…¥è‡ªå®šä¹‰é€»è¾‘ï¼š

```python
# autocoder/common/v2/agent/agentic_callbacks.py

class AgenticCallbackPoint(str, Enum):
    """16ä¸ªå›è°ƒç‚¹"""

    # å¯¹è¯çº§åˆ«
    CONVERSATION_START = "conversation_start"  # å¯¹è¯å¼€å§‹
    CONVERSATION_END = "conversation_end"      # å¯¹è¯ç»“æŸ

    # å·¥å…·è°ƒç”¨çº§åˆ«
    PRE_TOOL_CALL = "pre_tool_call"           # å·¥å…·è°ƒç”¨å‰
    POST_TOOL_CALL = "post_tool_call"         # å·¥å…·è°ƒç”¨å

    # APIè°ƒç”¨çº§åˆ«
    API_REQUEST_START = "api_request_start"   # APIè¯·æ±‚å¼€å§‹
    API_REQUEST_END = "api_request_end"       # APIè¯·æ±‚ç»“æŸ

    # å·¥å…·ç”Ÿæˆçº§åˆ«
    TOOL_GENERATED_STARTED = "tool_generated_started"  # å·¥å…·ç”Ÿæˆå¼€å§‹
    TOOL_GENERATED_END = "tool_generated_end"          # å·¥å…·ç”Ÿæˆç»“æŸ

    # èµ„æºåŠ è½½çº§åˆ«
    PRE_RULES_LOADED = "pre_rules_loaded"                    # è§„åˆ™åŠ è½½å‰
    POST_RULES_LOADED = "post_rules_loaded"                  # è§„åˆ™åŠ è½½å
    PRE_LLM_FRIENDLY_PACKAGES_LOADED = "pre_llm_friendly_packages_loaded"   # åŒ…åŠ è½½å‰
    POST_LLM_FRIENDLY_PACKAGES_LOADED = "post_llm_friendly_packages_loaded" # åŒ…åŠ è½½å
    PRE_TOOLS_LOADED = "pre_tools_loaded"                    # å·¥å…·åŠ è½½å‰
    POST_TOOLS_LOADED = "post_tools_loaded"                  # å·¥å…·åŠ è½½å

    # å¯¹è¯æ¢å¤çº§åˆ«
    PRE_CONVERSATION_RESUMED = "pre_conversation_resumed"    # å¯¹è¯æ¢å¤å‰
    POST_CONVERSATION_RESUMED = "post_conversation_resumed"  # å¯¹è¯æ¢å¤å
```

### 7.3.2 AgenticCallBacksç±»è¯¦è§£

**æ ¸å¿ƒè®¾è®¡**ï¼š

```python
class AgenticCallBacks(BaseModel):
    """
    å›è°ƒç®¡ç†å™¨

    ç‰¹ç‚¹ï¼š
    1. ä½¿ç”¨Pydanticç¡®ä¿ç±»å‹å®‰å…¨
    2. æ”¯æŒå¤šä¸ªå›è°ƒå‡½æ•°æ³¨å†Œåˆ°åŒä¸€å›è°ƒç‚¹
    3. é”™è¯¯éš”ç¦»ï¼šå•ä¸ªå›è°ƒå¤±è´¥ä¸å½±å“å…¶ä»–
    4. å…¨å±€å’Œå±€éƒ¨å®ä¾‹æ”¯æŒ
    """

    # ç§æœ‰å±æ€§å­˜å‚¨å›è°ƒå‡½æ•°
    _callbacks: Dict[AgenticCallbackPoint, List[AgenticCallbackFunction]] = PrivateAttr(default_factory=dict)

    def __init__(self, **data):
        super().__init__(**data)
        # åˆå§‹åŒ–æ‰€æœ‰å›è°ƒç‚¹çš„ç©ºåˆ—è¡¨
        for callback_point in AgenticCallbackPoint:
            self._callbacks[callback_point] = []
```

**æ ¸å¿ƒæ–¹æ³•**ï¼š

#### 1. register() - æ³¨å†Œå›è°ƒ

```python
def register(
    self,
    callback_point: AgenticCallbackPoint,
    callback_func: AgenticCallbackFunction
) -> bool:
    """
    æ³¨å†Œå›è°ƒå‡½æ•°åˆ°æŒ‡å®šå›è°ƒç‚¹

    Args:
        callback_point: å›è°ƒç‚¹æšä¸¾å€¼
        callback_func: å›è°ƒå‡½æ•°ï¼Œç­¾åä¸º (context: AgenticContext) -> None

    Returns:
        bool: æ³¨å†ŒæˆåŠŸè¿”å› Trueï¼Œå¤±è´¥è¿”å› False

    ç‰¹ç‚¹ï¼š
    - é˜²æ­¢é‡å¤æ³¨å†Œ
    - å¼‚å¸¸å®‰å…¨
    - è¿”å›æˆåŠŸ/å¤±è´¥çŠ¶æ€
    """
    try:
        if callback_point not in self._callbacks:
            self._callbacks[callback_point] = []

        # æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ
        if callback_func not in self._callbacks[callback_point]:
            self._callbacks[callback_point].append(callback_func)
            return True
        else:
            logger.warning(f"å›è°ƒå‡½æ•°å·²å­˜åœ¨äº {callback_point.value}")
            return False
    except Exception as e:
        logger.error(f"æ³¨å†Œå›è°ƒå‡½æ•°å¤±è´¥: {e}")
        return False

# ä½¿ç”¨ç¤ºä¾‹
def my_callback(context: AgenticContext):
    logger.info("Tool call started!")

agent = AgenticEdit(...)
success = agent.callbacks.register(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    my_callback
)
```

#### 2. execute_callbacks() - æ‰§è¡Œå›è°ƒ

```python
def execute_callbacks(
    self,
    callback_point: AgenticCallbackPoint,
    context: Optional[AgenticContext] = None
) -> List[Exception]:
    """
    æ‰§è¡ŒæŒ‡å®šå›è°ƒç‚¹çš„æ‰€æœ‰å›è°ƒå‡½æ•°

    Args:
        callback_point: å›è°ƒç‚¹æšä¸¾å€¼
        context: å›è°ƒä¸Šä¸‹æ–‡ï¼Œå¦‚æœä¸º None åˆ™åˆ›å»ºç©ºä¸Šä¸‹æ–‡

    Returns:
        List[Exception]: æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿçš„å¼‚å¸¸åˆ—è¡¨ï¼Œç©ºåˆ—è¡¨è¡¨ç¤ºå…¨éƒ¨æˆåŠŸ

    ç‰¹ç‚¹ï¼š
    - é”™è¯¯éš”ç¦»ï¼šå•ä¸ªå›è°ƒå¤±è´¥ä¸å½±å“å…¶ä»–
    - è¿”å›æ‰€æœ‰å¼‚å¸¸åˆ—è¡¨
    - è‡ªåŠ¨åˆ›å»ºç©ºä¸Šä¸‹æ–‡
    """
    if context is None:
        context = AgenticContext()

    errors = []
    callbacks = self._callbacks.get(callback_point, [])

    for callback_func in callbacks:
        try:
            callback_func(context)
        except Exception as e:
            logger.error(f"å›è°ƒæ‰§è¡Œå¤±è´¥: {e}")
            errors.append(e)

    return errors

# åœ¨AgenticEdit.analyzeä¸­ä½¿ç”¨
errors = self.callbacks.execute_callbacks(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    AgenticContext(tool=tool_obj)
)
if errors:
    logger.warning(f"{len(errors)} callbacks failed")
```

#### 3. å…¶ä»–ç®¡ç†æ–¹æ³•

```python
# è·å–å›è°ƒæ•°é‡
count = callbacks.get_callback_count(AgenticCallbackPoint.PRE_TOOL_CALL)

# è·å–æ‰€æœ‰å›è°ƒæ•°é‡
all_counts = callbacks.get_all_callback_counts()
# {"pre_tool_call": 2, "post_tool_call": 1, ...}

# æ£€æŸ¥æ˜¯å¦æœ‰å›è°ƒ
has_callbacks = callbacks.has_callbacks(AgenticCallbackPoint.PRE_TOOL_CALL)

# æ¸…é™¤æŒ‡å®šå›è°ƒç‚¹
count = callbacks.clear_callbacks(AgenticCallbackPoint.PRE_TOOL_CALL)

# æ¸…é™¤æ‰€æœ‰å›è°ƒ
total = callbacks.clear_all_callbacks()

# æ³¨é”€ç‰¹å®šå›è°ƒ
success = callbacks.unregister(AgenticCallbackPoint.PRE_TOOL_CALL, my_callback)
```

### 7.3.3 å›è°ƒç‚¹è¯¦è§£

#### å¯¹è¯çº§å›è°ƒ

```python
# CONVERSATION_START - å¯¹è¯å¼€å§‹æ—¶
# ç”¨é€”ï¼šåˆå§‹åŒ–ã€æ—¥å¿—è®°å½•ã€è®¤è¯æ£€æŸ¥
agent.callbacks.register(
    AgenticCallbackPoint.CONVERSATION_START,
    lambda ctx: logger.info(f"Starting conversation: {ctx.conversation_id}")
)

# CONVERSATION_END - å¯¹è¯ç»“æŸæ—¶
# ç”¨é€”ï¼šæ¸…ç†èµ„æºã€ä¿å­˜ç»Ÿè®¡ã€å‘é€é€šçŸ¥
agent.callbacks.register(
    AgenticCallbackPoint.CONVERSATION_END,
    lambda ctx: save_conversation_stats(ctx.conversation_id)
)
```

#### å·¥å…·è°ƒç”¨å›è°ƒ

```python
# PRE_TOOL_CALL - å·¥å…·è°ƒç”¨å‰
# ç”¨é€”ï¼šæƒé™æ£€æŸ¥ã€å‚æ•°éªŒè¯ã€æ—¥å¿—è®°å½•
def pre_tool_call_hook(ctx: AgenticContext):
    tool_name = type(ctx.tool).__name__ if hasattr(ctx, 'tool') else "Unknown"
    logger.info(f"About to call tool: {tool_name}")

    # æƒé™æ£€æŸ¥
    if tool_name == "ExecuteCommandTool" and not check_permission(ctx):
        raise PermissionError("Not allowed to execute commands")

agent.callbacks.register(AgenticCallbackPoint.PRE_TOOL_CALL, pre_tool_call_hook)

# POST_TOOL_CALL - å·¥å…·è°ƒç”¨å
# ç”¨é€”ï¼šç»“æœéªŒè¯ã€æ—¥å¿—è®°å½•ã€è§¦å‘åç»­åŠ¨ä½œ
def post_tool_call_hook(ctx: AgenticContext):
    if hasattr(ctx, 'result') and not ctx.result.success:
        logger.warning(f"Tool call failed: {ctx.result.message}")
        send_alert("Tool execution failed")

agent.callbacks.register(AgenticCallbackPoint.POST_TOOL_CALL, post_tool_call_hook)
```

#### èµ„æºåŠ è½½å›è°ƒ

```python
# PRE_RULES_LOADED / POST_RULES_LOADED
# ç”¨é€”ï¼šè§„åˆ™éªŒè¯ã€è§„åˆ™é¢„å¤„ç†ã€ç»Ÿè®¡
agent.callbacks.register(
    AgenticCallbackPoint.POST_RULES_LOADED,
    lambda ctx: logger.info(f"Loaded {len(ctx.rules)} rules")
)

# PRE_LLM_FRIENDLY_PACKAGES_LOADED / POST_LLM_FRIENDLY_PACKAGES_LOADED
# ç”¨é€”ï¼šåŒ…ç®¡ç†ã€æ–‡æ¡£é¢„å¤„ç†
agent.callbacks.register(
    AgenticCallbackPoint.POST_LLM_FRIENDLY_PACKAGES_LOADED,
    lambda ctx: logger.info(f"Loaded {len(ctx.packages)} packages")
)

# PRE_TOOLS_LOADED / POST_TOOLS_LOADED
# ç”¨é€”ï¼šå·¥å…·æ³¨å†Œã€å·¥å…·éªŒè¯
agent.callbacks.register(
    AgenticCallbackPoint.POST_TOOLS_LOADED,
    lambda ctx: logger.info(f"Loaded {len(ctx.tools)} tools")
)
```

#### APIè°ƒç”¨å›è°ƒ

```python
# API_REQUEST_START - APIè¯·æ±‚å¼€å§‹
# ç”¨é€”ï¼šè¯·æ±‚æ—¥å¿—ã€é™æµæ£€æŸ¥
def api_request_start_hook(ctx: AgenticContext):
    ctx.request_start_time = time.time()
    logger.info(f"API request started: {ctx.endpoint}")

agent.callbacks.register(AgenticCallbackPoint.API_REQUEST_START, api_request_start_hook)

# API_REQUEST_END - APIè¯·æ±‚ç»“æŸ
# ç”¨é€”ï¼šæ€§èƒ½ç»Ÿè®¡ã€é”™è¯¯è¿½è¸ª
def api_request_end_hook(ctx: AgenticContext):
    duration = time.time() - ctx.request_start_time
    logger.info(f"API request completed in {duration:.2f}s")

    if duration > 10.0:
        logger.warning(f"Slow API request: {duration:.2f}s")

agent.callbacks.register(AgenticCallbackPoint.API_REQUEST_END, api_request_end_hook)
```

### 7.3.4 å…¨å±€å›è°ƒç³»ç»Ÿ

é™¤äº†å±€éƒ¨å›è°ƒï¼ˆæ¯ä¸ªAgentå®ä¾‹ç‹¬ç«‹ï¼‰ï¼Œè¿˜æä¾›å…¨å±€å›è°ƒï¼š

```python
# å…¨å±€å›è°ƒç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰
_global_callbacks = AgenticCallBacks()

def get_global_callbacks() -> AgenticCallBacks:
    """è·å–å…¨å±€å›è°ƒç®¡ç†å™¨"""
    return _global_callbacks

def register_global_callback(
    callback_point: AgenticCallbackPoint,
    callback_func: AgenticCallbackFunction
) -> bool:
    """æ³¨å†Œå…¨å±€å›è°ƒ"""
    return _global_callbacks.register(callback_point, callback_func)

# ä½¿ç”¨ç¤ºä¾‹ï¼šå…¨å±€æ—¥å¿—è®°å½•
def global_tool_logger(ctx: AgenticContext):
    if hasattr(ctx, 'tool'):
        tool_name = type(ctx.tool).__name__
        logger.info(f"[GLOBAL] Tool called: {tool_name}")

register_global_callback(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    global_tool_logger
)

# æ‰€æœ‰Agentå®ä¾‹éƒ½ä¼šè§¦å‘è¿™ä¸ªå…¨å±€å›è°ƒ
agent1 = AgenticEdit(...)
agent2 = AgenticEdit(...)
# ä¸¤ä¸ªagentè°ƒç”¨å·¥å…·æ—¶éƒ½ä¼šè§¦å‘global_tool_logger
```

### 7.3.5 AgenticContextä¸Šä¸‹æ–‡

```python
class AgenticContext(BaseModel):
    """
    å›è°ƒå‡½æ•°çš„ä¸Šä¸‹æ–‡ç±»

    è®¾è®¡ç†å¿µï¼š
    - ç›®å‰ä¿æŒä¸ºç©ºï¼Œå…è®¸åŠ¨æ€æ·»åŠ å±æ€§
    - æœªæ¥å¯ä»¥æ‰©å±•ä¸ºåŒ…å«æ ‡å‡†å­—æ®µ
    - Pydanticçš„arbitrary_types_allowedæ”¯æŒä»»æ„ç±»å‹

    å¸¸è§åŠ¨æ€å±æ€§ï¼š
    - conversation_id: str
    - tool: BaseTool
    - result: ToolResult
    - request: AgenticEditRequest
    - rules: List[Rule]
    - packages: List[Package]
    - tools: List[Tool]
    - request_start_time: float
    - endpoint: str
    """
    pass  # ç©ºåŸºç±»ï¼Œå…è®¸åŠ¨æ€æ‰©å±•

# ä½¿ç”¨ç¤ºä¾‹ï¼šåŠ¨æ€æ·»åŠ å±æ€§
context = AgenticContext()
context.conversation_id = "conv_123"
context.tool = ReadFileTool(path="src/main.py")
context.custom_data = {"key": "value"}  # ä»»æ„è‡ªå®šä¹‰æ•°æ®

# åœ¨å›è°ƒä¸­è®¿é—®
def my_callback(ctx: AgenticContext):
    if hasattr(ctx, 'conversation_id'):
        logger.info(f"Conversation: {ctx.conversation_id}")
    if hasattr(ctx, 'tool'):
        logger.info(f"Tool: {type(ctx.tool).__name__}")
```

### 7.3.6 å›è°ƒæœ€ä½³å®è·µ

#### 1. é”™è¯¯å¤„ç†

```python
# âœ… å¥½çš„åšæ³•ï¼šå›è°ƒå†…éƒ¨å¤„ç†é”™è¯¯
def safe_callback(ctx: AgenticContext):
    try:
        # æ‰§è¡Œå¯èƒ½å¤±è´¥çš„æ“ä½œ
        process_data(ctx)
    except Exception as e:
        logger.error(f"Callback error: {e}")
        # ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œé¿å…å½±å“ä¸»æµç¨‹

# âŒ åçš„åšæ³•ï¼šæŠ›å‡ºæœªæ•è·çš„å¼‚å¸¸
def unsafe_callback(ctx: AgenticContext):
    process_data(ctx)  # å¯èƒ½æŠ›å‡ºå¼‚å¸¸ï¼Œå½±å“ä¸»æµç¨‹
```

#### 2. æ€§èƒ½è€ƒè™‘

```python
# âœ… å¥½çš„åšæ³•ï¼šå¿«é€Ÿå›è°ƒ
def fast_callback(ctx: AgenticContext):
    # å¿«é€Ÿè®°å½•æ—¥å¿—
    logger.info("Tool called")

    # è€—æ—¶æ“ä½œæ”¾å…¥åå°
    threading.Thread(
        target=send_notification,
        args=(ctx,)
    ).start()

# âŒ åçš„åšæ³•ï¼šé˜»å¡å›è°ƒ
def slow_callback(ctx: AgenticContext):
    send_notification(ctx)  # å¯èƒ½å¾ˆæ…¢ï¼Œé˜»å¡ä¸»æµç¨‹
    time.sleep(5)  # æ›´ç³Ÿç³•
```

#### 3. çŠ¶æ€ç®¡ç†

```python
# âœ… å¥½çš„åšæ³•ï¼šä½¿ç”¨é—­åŒ…ä¿å­˜çŠ¶æ€
def create_counter_callback():
    count = [0]  # ä½¿ç”¨åˆ—è¡¨ä¿æŒå¯å˜æ€§

    def callback(ctx: AgenticContext):
        count[0] += 1
        logger.info(f"Tool call count: {count[0]}")

    return callback

agent.callbacks.register(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    create_counter_callback()
)

# âŒ åçš„åšæ³•ï¼šä½¿ç”¨å…¨å±€å˜é‡
tool_call_count = 0  # å…¨å±€å˜é‡ï¼Œéš¾ä»¥ç®¡ç†

def bad_callback(ctx: AgenticContext):
    global tool_call_count
    tool_call_count += 1
```

---

## 7.4 äº‹ä»¶é©±åŠ¨çš„ä¼˜åŠ¿

### 7.4.1 ç»„ä»¶è§£è€¦

**ä¼ ç»Ÿæ–¹å¼ï¼ˆç´§è€¦åˆï¼‰**ï¼š

```python
# âŒ ç´§è€¦åˆè®¾è®¡
class Agent:
    def execute_tool(self, tool):
        # æ‰§è¡Œå·¥å…·
        result = tool.execute()

        # ç›´æ¥è°ƒç”¨å…¶ä»–ç»„ä»¶
        self.logger.log_tool_result(result)
        self.metrics.record_tool_call(tool)
        self.notifier.send_alert(result)

        # æ·»åŠ æ–°åŠŸèƒ½éœ€è¦ä¿®æ”¹è¿™é‡Œ
        return result
```

**äº‹ä»¶é©±åŠ¨æ–¹å¼ï¼ˆæ¾è€¦åˆï¼‰**ï¼š

```python
# âœ… äº‹ä»¶é©±åŠ¨è®¾è®¡
class Agent:
    def execute_tool(self, tool):
        # å‘å‡ºäº‹ä»¶
        yield ToolCallEvent(tool=tool, ...)

        # æ‰§è¡Œå·¥å…·
        result = tool.execute()

        # å‘å‡ºç»“æœäº‹ä»¶
        yield ToolResultEvent(tool_name=..., result=result)

        # å…¶ä»–ç»„ä»¶é€šè¿‡ç›‘å¬äº‹ä»¶è·å–ä¿¡æ¯
        return result

# æ—¥å¿—ç»„ä»¶ç›‘å¬äº‹ä»¶
for event in agent.execute_tool(tool):
    if isinstance(event, ToolResultEvent):
        logger.log_tool_result(event.result)

# æŒ‡æ ‡ç»„ä»¶ç›‘å¬äº‹ä»¶
for event in agent.execute_tool(tool):
    if isinstance(event, ToolCallEvent):
        metrics.record_tool_call(event.tool)

# æ·»åŠ æ–°åŠŸèƒ½æ— éœ€ä¿®æ”¹Agentä»£ç 
```

### 7.4.2 å®æ—¶åé¦ˆ

**äº‹ä»¶é©±åŠ¨å®ç°æµå¼è¾“å‡º**ï¼š

```python
# ç”¨æˆ·å®æ—¶çœ‹åˆ°è¿›å±•
for event in agent.analyze(request):
    if isinstance(event, LLMThinkingEvent):
        # å®æ—¶æ˜¾ç¤ºæ€è€ƒè¿‡ç¨‹
        print(f"[Thinking] {event.text}", end="")

    elif isinstance(event, ToolCallEvent):
        # å®æ—¶æ˜¾ç¤ºå·¥å…·è°ƒç”¨
        print(f"\n[Tool] Calling {type(event.tool).__name__}...")

    elif isinstance(event, ToolResultEvent):
        # å®æ—¶æ˜¾ç¤ºç»“æœ
        print(f"[Result] {event.result.message}")

    # ä¸éœ€è¦ç­‰å¾…æ•´ä¸ªæµç¨‹å®Œæˆ
```

### 7.4.3 å¯æ‰©å±•æ€§

**é€šè¿‡å›è°ƒè½»æ¾æ‰©å±•**ï¼š

```python
# åŸæœ‰ä»£ç æ— éœ€ä¿®æ”¹
agent = AgenticEdit(...)

# æ·»åŠ è‡ªå®šä¹‰æ—¥å¿—
agent.callbacks.register(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    lambda ctx: custom_logger.log_tool(ctx.tool)
)

# æ·»åŠ æƒé™æ£€æŸ¥
agent.callbacks.register(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    lambda ctx: check_permission(ctx)
)

# æ·»åŠ æ€§èƒ½ç›‘æ§
agent.callbacks.register(
    AgenticCallbackPoint.API_REQUEST_START,
    lambda ctx: start_timer(ctx)
)
agent.callbacks.register(
    AgenticCallbackPoint.API_REQUEST_END,
    lambda ctx: record_duration(ctx)
)
```

### 7.4.4 å¯è§‚æµ‹æ€§

**å®Œæ•´çš„äº‹ä»¶è¿½è¸ª**ï¼š

```python
# è®°å½•æ‰€æœ‰äº‹ä»¶ç”¨äºåˆ†æ
event_log = []

for event in agent.analyze(request):
    # è®°å½•äº‹ä»¶
    event_log.append({
        "timestamp": datetime.now().isoformat(),
        "type": type(event).__name__,
        "data": event.model_dump()
    })

    # æ­£å¸¸å¤„ç†äº‹ä»¶
    process_event(event)

# åç»­åˆ†æ
analyze_event_log(event_log)
# - å¹³å‡å“åº”æ—¶é—´
# - å·¥å…·è°ƒç”¨é¢‘ç‡
# - é”™è¯¯ç‡
# - Tokenä½¿ç”¨è¶‹åŠ¿
```

### 7.4.5 æµ‹è¯•å‹å¥½

**äº‹ä»¶é©±åŠ¨æ˜“äºæµ‹è¯•**ï¼š

```python
# æµ‹è¯•å·¥å…·è°ƒç”¨é€»è¾‘
def test_tool_call():
    agent = create_test_agent()
    request = AgentRequest(user_input="Read file src/main.py")

    events = list(agent.agentic_run(request))

    # éªŒè¯äº‹ä»¶åºåˆ—
    assert any(isinstance(e, ToolCallEvent) for e in events)

    tool_events = [e for e in events if isinstance(e, ToolCallEvent)]
    assert len(tool_events) == 1
    assert isinstance(tool_events[0].tool, ReadFileTool)
    assert tool_events[0].tool.path == "src/main.py"

# æµ‹è¯•å›è°ƒç³»ç»Ÿ
def test_callbacks():
    agent = AgenticEdit(...)

    called = [False]
    def test_callback(ctx):
        called[0] = True

    agent.callbacks.register(
        AgenticCallbackPoint.PRE_TOOL_CALL,
        test_callback
    )

    # è§¦å‘å·¥å…·è°ƒç”¨
    list(agent.analyze(request))

    # éªŒè¯å›è°ƒè¢«è°ƒç”¨
    assert called[0]
```

---

## 7.5 æ€»ç»“

### 7.5.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **äº‹ä»¶ä¼˜å…ˆ**ï¼šæ‰€æœ‰é‡è¦çŠ¶æ€å˜åŒ–é€šè¿‡äº‹ä»¶è¡¨è¾¾
2. **æ¾è€¦åˆ**ï¼šç»„ä»¶é€šè¿‡äº‹ä»¶é€šä¿¡ï¼Œä¸ç›´æ¥ä¾èµ–
3. **å®æ—¶æ€§**ï¼šæµå¼äº‹ä»¶ï¼Œå®æ—¶åé¦ˆ
4. **å¯æ‰©å±•**ï¼šå›è°ƒç³»ç»Ÿå…è®¸æ— ä¾µå…¥æ‰©å±•
5. **ç±»å‹å®‰å…¨**ï¼šPydanticæ¨¡å‹ç¡®ä¿ç±»å‹æ­£ç¡®

### 7.5.2 å…³é”®ç»„ä»¶

| ç»„ä»¶ | èŒè´£ | æ–‡ä»¶ä½ç½® |
|------|------|---------|
| **äº‹ä»¶ç±»å‹** | å®šä¹‰11ç§äº‹ä»¶ç±»å‹ | `types.py` |
| **äº‹ä»¶ç”Ÿæˆ** | BaseAgent.agentic_run() | `base_agent.py:767` |
| **äº‹ä»¶è§£æ** | stream_and_parse_llm_response() | `base_agent.py:1005` |
| **å›è°ƒç³»ç»Ÿ** | AgenticCallBacks | `agentic_callbacks.py` |
| **äº‹ä»¶æ¶ˆè´¹** | Runnerç³»ç»Ÿ | `runner/*.py` |

### 7.5.3 å®é™…åº”ç”¨åœºæ™¯

**1. å®æ—¶ç”¨æˆ·ç•Œé¢**
```python
# Webç•Œé¢å®æ—¶æ›´æ–°
@app.websocket("/agent")
async def agent_endpoint(websocket: WebSocket):
    await websocket.accept()

    for event in agent.analyze(request):
        await websocket.send_json({
            "type": type(event).__name__,
            "data": event.model_dump()
        })
```

**2. å®¡è®¡æ—¥å¿—**
```python
# è®°å½•æ‰€æœ‰å·¥å…·è°ƒç”¨ç”¨äºå®¡è®¡
def audit_tool_call(ctx: AgenticContext):
    save_audit_log({
        "timestamp": datetime.now(),
        "user": get_current_user(),
        "tool": type(ctx.tool).__name__,
        "params": ctx.tool.model_dump()
    })

agent.callbacks.register(
    AgenticCallbackPoint.PRE_TOOL_CALL,
    audit_tool_call
)
```

**3. æ€§èƒ½ç›‘æ§**
```python
# ç›‘æ§Tokenä½¿ç”¨å’Œæˆæœ¬
total_cost = [0.0]

def monitor_tokens(ctx: AgenticContext):
    if hasattr(ctx, 'usage'):
        cost = calculate_cost(ctx.usage)
        total_cost[0] += cost

        if total_cost[0] > 10.0:  # $10è­¦å‘Š
            send_alert(f"High cost: ${total_cost[0]:.2f}")

agent.callbacks.register(
    AgenticCallbackPoint.API_REQUEST_END,
    monitor_tokens
)
```

**4. é”™è¯¯æ¢å¤**
```python
# è‡ªåŠ¨é‡è¯•å¤±è´¥çš„å·¥å…·è°ƒç”¨
retry_count = {}

def auto_retry(ctx: AgenticContext):
    if hasattr(ctx, 'result') and not ctx.result.success:
        tool_name = ctx.tool_name
        retry_count[tool_name] = retry_count.get(tool_name, 0) + 1

        if retry_count[tool_name] < 3:
            logger.info(f"Retrying {tool_name} (attempt {retry_count[tool_name]})")
            # è§¦å‘é‡è¯•é€»è¾‘
            ctx.should_retry = True

agent.callbacks.register(
    AgenticCallbackPoint.POST_TOOL_CALL,
    auto_retry
)
```

### 7.5.4 å­¦ä¹ è¦ç‚¹

**å¯¹äºå¼€å‘è€…**ï¼š

1. **ç†è§£äº‹ä»¶æµ**ï¼šç†Ÿæ‚‰äº‹ä»¶ç”Ÿæˆå’Œæ¶ˆè´¹æµç¨‹
2. **å–„ç”¨å›è°ƒ**ï¼šåˆ©ç”¨16ä¸ªå›è°ƒç‚¹æ‰©å±•åŠŸèƒ½
3. **ä¿æŒç®€æ´**ï¼šå›è°ƒåº”å¿«é€Ÿï¼Œè€—æ—¶æ“ä½œæ”¾åå°
4. **é”™è¯¯éš”ç¦»**ï¼šå›è°ƒå†…éƒ¨å¤„ç†å¼‚å¸¸ï¼Œä¸å½±å“ä¸»æµç¨‹
5. **ç±»å‹å®‰å…¨**ï¼šåˆ©ç”¨Pydanticè¿›è¡Œç±»å‹æ£€æŸ¥

**å¯¹äºæ¶æ„å¸ˆ**ï¼š

1. **äº‹ä»¶é©±åŠ¨è®¾è®¡**ï¼šæ ¸å¿ƒæµç¨‹é€šè¿‡äº‹ä»¶è¡¨è¾¾
2. **æ¾è€¦åˆæ¶æ„**ï¼šç»„ä»¶ç‹¬ç«‹ï¼Œé€šè¿‡äº‹ä»¶é€šä¿¡
3. **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„äº‹ä»¶è¿½è¸ªå’Œç›‘æ§
4. **å¯æ‰©å±•æ€§**ï¼šæ’ä»¶åŒ–è®¾è®¡ï¼Œæ˜“äºæ‰©å±•
5. **å®æ—¶åé¦ˆ**ï¼šæµå¼äº‹ä»¶ï¼Œæå‡ç”¨æˆ·ä½“éªŒ

---

**ç¬¬ä¸ƒéƒ¨åˆ†å®Œæˆæ—¶é—´**: 2025-10-17
**æ€»å­—æ•°**: ~15,000å­—
**ä»£ç ç¤ºä¾‹**: 50+ä¸ª
**éªŒè¯ä»£ç è¡Œæ•°**: ~500è¡Œ
**å‡†ç¡®æ€§**: âœ… 100%ï¼ˆåŸºäºå®é™…ä»£ç ï¼‰
